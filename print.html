<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ecam Eurobot</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="organization/organization.html"><strong aria-hidden="true">1.</strong> Organization</a></li><li><ol class="section"><li><a href="organization/github.html"><strong aria-hidden="true">1.1.</strong> GitHub</a></li><li><ol class="section"><li><a href="organization/gh-admin.html"><strong aria-hidden="true">1.1.1.</strong> Administration</a></li></ol></li><li><a href="organization/mdbook.html"><strong aria-hidden="true">1.2.</strong> mdBook</a></li></ol></li><li><a href="mechanical/mechanical.html"><strong aria-hidden="true">2.</strong> Mechanical</a></li><li><ol class="section"><li><a href="mechanical/fusion.html"><strong aria-hidden="true">2.1.</strong> 3D modeling with Fusion360</a></li><li><a href="mechanical/3d-print.html"><strong aria-hidden="true">2.2.</strong> 3D printing</a></li><li><a href="mechanical/mecanum.html"><strong aria-hidden="true">2.3.</strong> Mecanum wheels</a></li><li><a href="mechanical/vacuum.html"><strong aria-hidden="true">2.4.</strong> Vacuum prehention</a></li><li><a href="mechanical/2018/2018.html"><strong aria-hidden="true">2.5.</strong> 2018 specifics</a></li><li><ol class="section"><li><a href="mechanical/2018/bigRobot.html"><strong aria-hidden="true">2.5.1.</strong> Block mechanism</a></li><li><a href="mechanical/2018/balls.html"><strong aria-hidden="true">2.5.2.</strong> Ball mechanism</a></li></ol></li></ol></li><li><a href="electronics/electronics.html"><strong aria-hidden="true">3.</strong> Electronics</a></li><li><ol class="section"><li><a href="electronics/actuators/actuators.html"><strong aria-hidden="true">3.1.</strong> Actuators</a></li><li><ol class="section"><li><a href="electronics/actuators/dynamixels.html"><strong aria-hidden="true">3.1.1.</strong> Dynamixels</a></li></ol></li><li><a href="electronics/sensors/sensors.html"><strong aria-hidden="true">3.2.</strong> Sensors</a></li><li><ol class="section"><li><a href="electronics/sensors/sonar.html"><strong aria-hidden="true">3.2.1.</strong> Sonar</a></li><li><a href="electronics/sensors/coloursensor.html"><strong aria-hidden="true">3.2.2.</strong> Color Sensor</a></li><li><a href="electronics/sensors/mouse.html"><strong aria-hidden="true">3.2.3.</strong> Mouse</a></li></ol></li><li><a href="electronics/pcb/1_PCB_Design.html"><strong aria-hidden="true">3.3.</strong> PCB Design</a></li><li><ol class="section"><li><a href="electronics/pcb/2_Starting_Board.html"><strong aria-hidden="true">3.3.1.</strong> Start board</a></li><li><a href="electronics/pcb/3_Motor_Board.html"><strong aria-hidden="true">3.3.2.</strong> Motor board</a></li><li><a href="electronics/pcb/4_Com_Shield.html"><strong aria-hidden="true">3.3.3.</strong> Communication shield</a></li><li><a href="electronics/pcb/PowerSpply.html"><strong aria-hidden="true">3.3.4.</strong> Power supply board</a></li><li><a href="electronics/pcb/5_Appendix.html"><strong aria-hidden="true">3.3.5.</strong> Appendix</a></li></ol></li><li><a href="electronics/fpga.html"><strong aria-hidden="true">3.4.</strong> FPGA</a></li><li><a href="electronics/communication/communication.html"><strong aria-hidden="true">3.5.</strong> Communication</a></li><li><ol class="section"><li><a href="electronics/communication/i2c.html"><strong aria-hidden="true">3.5.1.</strong> I2C</a></li><li><a href="electronics/communication/spi.html"><strong aria-hidden="true">3.5.2.</strong> SPI</a></li><li><a href="electronics/communication/can.html"><strong aria-hidden="true">3.5.3.</strong> CAN</a></li></ol></li></ol></li><li><a href="software/software.html"><strong aria-hidden="true">4.</strong> Software</a></li><li><ol class="section"><li><a href="software/docker.html"><strong aria-hidden="true">4.1.</strong> Docker</a></li><li><a href="software/ros/ros.html"><strong aria-hidden="true">4.2.</strong> ROS</a></li><li><ol class="section"><li><a href="software/ros/install.html"><strong aria-hidden="true">4.2.1.</strong> Install</a></li><li><a href="software/ros/basics/basics.html"><strong aria-hidden="true">4.2.2.</strong> Basic concepts</a></li><li><ol class="section"><li><a href="software/ros/basics/workspace.html"><strong aria-hidden="true">4.2.2.1.</strong> Workspace setup</a></li><li><a href="software/ros/basics/packages.html"><strong aria-hidden="true">4.2.2.2.</strong> Packages</a></li><li><a href="software/ros/basics/pub.html"><strong aria-hidden="true">4.2.2.3.</strong> Publisher</a></li><li><a href="software/ros/basics/sub.html"><strong aria-hidden="true">4.2.2.4.</strong> Subscriber</a></li><li><a href="software/ros/basics/example.html"><strong aria-hidden="true">4.2.2.5.</strong> Example</a></li><li><a href="software/ros/basics/launch.html"><strong aria-hidden="true">4.2.2.6.</strong> Launchfiles</a></li><li><a href="software/ros/basics/params.html"><strong aria-hidden="true">4.2.2.7.</strong> ROS parameters</a></li><li><a href="software/ros/basics/practices.html"><strong aria-hidden="true">4.2.2.8.</strong> Good Practices</a></li></ol></li><li><a href="software/ros/rosserial.html"><strong aria-hidden="true">4.2.3.</strong> ROS and Arduino</a></li><li><ol class="section"><li><a href="software/ros/arduino/publisher.html"><strong aria-hidden="true">4.2.3.1.</strong> Publisher</a></li><li><a href="software/ros/arduino/subscriber.html"><strong aria-hidden="true">4.2.3.2.</strong> Subscriber</a></li></ol></li><li><a href="software/ros/advanced/advanced.html"><strong aria-hidden="true">4.2.4.</strong> Advanced concepts</a></li><li><ol class="section"><li><a href="software/ros/advanced/custom-msgs.html"><strong aria-hidden="true">4.2.4.1.</strong> Custom messages</a></li><li><a href="software/ros/advanced/model.html"><strong aria-hidden="true">4.2.4.2.</strong> Robot model</a></li><li><a href="software/ros/advanced/rviz.html"><strong aria-hidden="true">4.2.4.3.</strong> Rviz</a></li></ol></li><li><a href="software/ros/packages/packages.html"><strong aria-hidden="true">4.2.5.</strong> Useful packages</a></li><li><ol class="section"><li><a href="software/ros/packages/map.html"><strong aria-hidden="true">4.2.5.1.</strong> Map Server</a></li><li><a href="software/ros/packages/nav.html"><strong aria-hidden="true">4.2.5.2.</strong> Navigation stack</a></li></ol></li></ol></li><li><a href="software/mecanum/mecanum.html"><strong aria-hidden="true">4.3.</strong> Mecanum wheels</a></li><li><a href="software/image-processing.html"><strong aria-hidden="true">4.4.</strong> Image processing</a></li></ol></li><li><a href="robots/robots.html"><strong aria-hidden="true">5.</strong> Robots</a></li><li><ol class="section"><li><a href="robots/2018.html"><strong aria-hidden="true">5.1.</strong> 2018</a></li><li><ol class="section"><li><a href="robots/structure.html"><strong aria-hidden="true">5.1.1.</strong> Structure of folder</a></li><li><a href="robots/2018/minus/minus.html"><strong aria-hidden="true">5.1.2.</strong> Minus (big robot)</a></li><li><ol class="section"><li><a href="robots/2018/minus/architecture.html"><strong aria-hidden="true">5.1.2.1.</strong> Architecture</a></li><li><a href="robots/2018/minus/packages.html"><strong aria-hidden="true">5.1.2.2.</strong> Packages</a></li><li><a href="robots/2018/minus/howto.html"><strong aria-hidden="true">5.1.2.3.</strong> How to run the robot</a></li></ol></li></ol></li><li><a href="robots/2019.html"><strong aria-hidden="true">5.2.</strong> 2019</a></li><li><ol class="section"><li><a href="robots/2019/soja.html"><strong aria-hidden="true">5.2.1.</strong> Soja</a></li><li><ol class="section"><li><a href="robots/2019/soja/code.html"><strong aria-hidden="true">5.2.1.1.</strong> Code</a></li><li><ol class="section"><li><a href="robots/2019/soja/code/motors.html"><strong aria-hidden="true">5.2.1.1.1.</strong> Arduino/motors.ino</a></li><li><a href="robots/2019/soja/code/odom.html"><strong aria-hidden="true">5.2.1.1.2.</strong> rpi/odom.cpp</a></li><li><a href="robots/2019/soja/code/move.html"><strong aria-hidden="true">5.2.1.1.3.</strong> rpi/move.py</a></li><li><a href="robots/2019/soja/code/ultrasound_rpi.html"><strong aria-hidden="true">5.2.1.1.4.</strong> rpi/ultrasound.py</a></li></ol></li><li><a href="robots/2019/soja/Encoders.html"><strong aria-hidden="true">5.2.1.2.</strong> Encoders</a></li><li><a href="robots/2019/soja/improvements.html"><strong aria-hidden="true">5.2.1.3.</strong> Improvements</a></li></ol></li></ol></li></ol></li><li><a href="graphic/graphic_chart.html">Appendix A: Graphic chart</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Ecam Eurobot</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p>This book contains learning ressources and tutorials about many of the technologies
we used for our participation(s) in the Eurobot contests.</p>
<p>The <a href="http://www.eurobot.org/">Eurobot contest</a> is an international amateur robotics contest.
The objective is to build an autonomous robot that needs to accomplish a given set of tasks, earning you points.</p>
<p>Through this book, we hope to be able to transfer the knowledge and experience we have acquired during our participation to
the team that will participate next year. Our hope is that over the years, this ressource will grow with each participation
to become a huge source of information for anyone that wants to participate in the contest.</p>
<a class="header" href="print.html#a2018" id="a2018"><h1>2018</h1></a>
<p><img src="img/2018.jpg" alt="Participants of 2018" /></p>
<a class="header" href="print.html#a2019" id="a2019"><h1>2019</h1></a>
<p><img src="img/2019.jpg" alt="Participants of 2019" /></p>
<a class="header" href="print.html#organization" id="organization"><h1>Organization</h1></a>
<p>When working in a team, it is crucial to have a good way to share files, code and ressources
with other members of the team. In this chapter, we explain what tools we used and how
we organized our workflow for a good cooperation.</p>
<p>To share code, we use <a href="https://github.com/Ecam-Eurobot">GitHub</a> and <a href="https://git-scm.com/"><code>git</code></a>,
we have a shared Fusion360 project to store our 3D models and we have a Google Drive / OneDrive to
store all other files.</p>
<p>We create an office Teams to share all the non-officials files. So everybody have aces to all the information. It was the centralized drive.</p>
<a class="header" href="print.html#github" id="github"><h1>GitHub</h1></a>
<p><a href="https://github.com/">GitHub</a> is a hosting service for software projects that use <a href="https://git-scm.com/"><code>git</code></a> for version control.
GitHub allows us to upload software projects to the cloud in order to facilitate collaboration. You can control who can and can't
contribute to a project and provides tools like <a href="https://guides.github.com/features/issues/">bug tracking</a>.</p>
<blockquote>
<p>It is important to note that GitHub and Git are very separate things.</p>
<ul>
<li><strong>Git</strong> is a version control system that allows to keep a history of changes made to source code files</li>
<li><strong>GitHub</strong> is a hosting service that allows to upload Git repositories to the cloud for easier collaboration and sharing</li>
</ul>
</blockquote>
<a class="header" href="print.html#introduction-to-git-and-github" id="introduction-to-git-and-github"><h2>Introduction to Git and GitHub</h2></a>
<p>If you have never used Git or GitHub, we recommend that you get familiar with it. They are incredibly powerful tools.
GitHub has a <a href="https://guides.github.com/">series of simple tutorials</a> that you can follow to get the basics.
We particularily recommend to read at least:</p>
<ul>
<li><a href="https://guides.github.com/activities/hello-world/">Hello World</a> to learn how to create a repository on GitHub</li>
<li><a href="https://guides.github.com/introduction/flow/">Understanding the GitHub Flow</a> to learn how to use GitHub's Web interface
to contribute to a project</li>
<li><a href="https://guides.github.com/introduction/git-handbook/">Git Handbook</a> to learn the basics of Git and how to do the same as
the tutorial above but using Git directly in the command line. Using the terminal may not seem intuitive, but once you
understand how it works, it will greatly improve your productivity.</li>
<li><a href="https://guides.github.com/activities/forking/">Forking Projects</a> to learn how to contribute to projects where you don't
have write permissions.</li>
</ul>
<a class="header" href="print.html#ecam-eurobot-organization" id="ecam-eurobot-organization"><h2>Ecam-Eurobot organization</h2></a>
<p>GitHub allows us to create <em>organizations</em> so that multiple users can easily contribute to multiple projects in the organization.
We created the <a href="https://github.com/Ecam-Eurobot">Ecam-Eurobot</a> organization to put all our code under.</p>
<p>You can for example find the <a href="https://github.com/Ecam-Eurobot/Eurobot-2018">2018 repository</a> containing the codes for the
2018 robots, or the source code for this book in the <a href="https://github.com/Ecam-Eurobot/Tutorials">Tutorials repository</a>.</p>
<p>We create a new repository for each year. This allows us to keep old members in the organization with write access to the
projects they made and welcome new members with write access to the repository they contribute to.</p>
<a class="header" href="print.html#administration" id="administration"><h1>Administration</h1></a>
<p>To add new members to the organization and configure their permissions, we need an
administrator. Each year an administrator is designed who preferably has experience with
Git and GitHub in order to help his peers and resolve any Git problems they may face.</p>
<blockquote>
<p>This chapter is destined for the person who administrates the GitHub organization</p>
</blockquote>
<p>The administrators for past years were:</p>
<ul>
<li><strong>2019</strong> <a href="https://github.com/orgs/Ecam-Eurobot/people/Diab0lix">@Diab0lix</a> (Thierry Frycia)</li>
<li><strong>2018</strong> <a href="https://github.com/azerupi">@azerupi</a> (Mathieu David)</li>
<li><strong>2017</strong> <a href="https://github.com/charlesvdv">@charlesvdv</a> (Charles Vandevoorde)</li>
</ul>
<p>You can contact them (most recent first preferably) if you are the chosen administrator for your team.
They will add you with the correct privileges.</p>
<a class="header" href="print.html#creating-a-new-repository" id="creating-a-new-repository"><h2>Creating a new repository</h2></a>
<p>As administrator, your task is to setup GitHub and the repositories so that everyone can work on the
project. The first thing you want to do is create a new repository for your year.</p>
<p>We do however recommend to base it off off the repository from previous year instead of starting from scratch.
As administrator, head over to the <a href="https://github.com/Ecam-Eurobot">organization's page</a> to create a new repository.</p>
<p><img src="img/organization/org.png" alt="org" /></p>
<p>Fill in the name with <code>Eurobot-xxxx</code> where <code>xxxx</code> represents the year. You can add a description if you want. Leave all
the rest blank because we are going to push the code of previous year in the newly created repository.</p>
<p><img src="img/organization/new-repo.png" alt="new repository" /></p>
<p>You will land on the following page</p>
<p><img src="img/organization/new-repo2.png" alt="new repository created" /></p>
<p>Let's push the repository from last year into the newly created repository.
On the command line, clone last years repository. In this case, I will clone <a href="https://github.com/Ecam-Eurobot/Eurobot-2018">Eurobot-2018</a></p>
<pre><code>git clone https://github.com/Ecam-Eurobot/Eurobot-2018.git
cd Eurobot-2018
</code></pre>
<p>Now you need to add the newly created repository as a remote. And verify that it was added correctly.</p>
<pre><code>git remote add next-year https://github.com/Ecam-Eurobot/Eurobot-2019.git
git remote -v
</code></pre>
<p>Push the repository into the newly created repository</p>
<pre><code>git push -u next-year master
</code></pre>
<p>If we refresh the GitHub page for the newly created repository, we can see something similar to below.
We can see (in the top left) that we are in the new repository and if we look at the <code>README</code> at the
bottom we can see that it contains the files from previous year. We can now start to work in the new
repository without affecting the old one.</p>
<p><img src="img/organization/new-repo3.png" alt="Repository pushed" /></p>
<blockquote>
<p><strong>Note:</strong><br />
Now that the new repository is created, you can remove your local clone of the repository from last year.
You will not need it anymore.</p>
</blockquote>
<a class="header" href="print.html#adding-teams" id="adding-teams"><h2>Adding teams</h2></a>
<p>Now that the repository is created, you need to add two <strong>teams</strong> to the Eurobot organization:</p>
<ul>
<li><strong>Eurobot &lt;year&gt;</strong>: this team will contain all the members participating this year. We will give this team the privileges to push to any branch <strong>except the master branch</strong>.</li>
<li><strong>Eurobot &lt;year&gt; Reviewers</strong>: this team will be given more privileges. They will be able to review and accept <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a>
to the master branch.</li>
</ul>
<blockquote>
<p><strong>Note:</strong><br />
The master branch should <strong>always</strong> be kept in a working state, this is the golden rule! As administrator, with help from the reviewers, it is your duty to make sure
that this rule is followed by everyone. The normal development process should be the following:</p>
<ol>
<li>For any new development a new branch is created by the member that develops it</li>
<li>He implements the new feature / behavior</li>
<li>When done, he creates a pull request against the master branch</li>
<li>At least one reviewer reads the changes, makes sure that the code meets the quality guidelines and aproves the changes</li>
<li>Only then can the code be merged into the master branch.</li>
</ol>
<p>Resist the urge of merging code that hasn't been reviewed.</p>
</blockquote>
<p>To create a new team, go to the GitHub organization: <a href="https://github.com/Ecam-Eurobot">Ecam-Eurobot</a> and go to the &quot;teams&quot; tab.</p>
<p><img src="img/organization/new-team-1.png" alt="teams" /></p>
<p>Then click the <strong>&quot;New team&quot;</strong> button, fill in the name as mentioned above and then click <strong>&quot;Create the team&quot;</strong>.</p>
<a class="header" href="print.html#give-them-correct-permissions" id="give-them-correct-permissions"><h3>Give them correct permissions</h3></a>
<p>Now that the teams are created, we need to give them the correct permissions. Go to the newly created repository, under <strong>&quot;Settings&quot;</strong>
go to the <strong>&quot;Collaborators &amp; Teams&quot;</strong> section.</p>
<p><img src="img/organization/new-team-2.png" alt="teams" /></p>
<p>Then add the teams you created with the <strong>write</strong> permissions, like below.</p>
<p><img src="img/organization/permissions-1.png" alt="permissions" /></p>
<p>Now go to the <strong>&quot;Branches&quot;</strong> section and add the master branch as a protected branch.</p>
<p><img src="img/organization/permissions-2.png" alt="protected branch" /></p>
<p>And configure the protections like in the image below:</p>
<p><img src="img/organization/permissions-3.png" alt="protected branch" /></p>
<p>This will prevent anyone from commiting to the master branch directly <strong>except</strong> the administrator and the reviewers, who need push access to accept pull requests.
Don't abuse these privileges, it is always better to have your code reviewed by others, even if you are a badass programmer!</p>
<a class="header" href="print.html#invite-members" id="invite-members"><h2>Invite members</h2></a>
<p>Now that everything is setup, we still need to invite the people who will be participating with you this year and assign them to the correct teams.
To do this, go to the organization's page again under the <strong>&quot;People&quot;</strong> tab and click on <strong>&quot;Invite member&quot;</strong>.</p>
<p><img src="img/organization/members-1.png" alt="members" /></p>
<p>Type in their GitHub user name and invite them. In the invitation, you can already assign them to the correct teams.</p>
<p><img src="img/organization/members-2.png" alt="members" /></p>
<p>Once the invitation has been sent, the invited user can accept the invitation by visiting the
organization's page: <a href="https://github.com/Ecam-Eurobot">https://github.com/Ecam-Eurobot</a>.</p>
<a class="header" href="print.html#mdbook" id="mdbook"><h1>mdBook</h1></a>
<p>To generate this online documentation &quot;book&quot;, we use a tool called <a href="https://github.com/rust-lang-nursery/mdBook">mdBook</a>.
This chapter will briefly introduce this tool in order for anyone to be able to contribute and improve this document.</p>
<p>The official documentation for mdBook can be found <a href="https://rust-lang-nursery.github.io/mdBook/">here</a></p>
<a class="header" href="print.html#structure-of-a-book" id="structure-of-a-book"><h2>Structure of a book</h2></a>
<p>A book has the following structure:</p>
<pre><code>book-test/
├── book.toml
├── book
└── src
    ├── chapter_1.md
    └── SUMMARY.md
</code></pre>
<p>The <strong><code>book.toml</code></strong> file contains the configuration options of the book.
In this file you can find the title, the authors, but also an option to enable math equation rendering, etc.
For a list of the options, refer to the official documentation. The <code>book.toml</code> file also represents the
root folder of the book. When we run mdBook, we need to either run it in that folder or point it to that folder.</p>
<p>In that same folder, you can find 2 folders: <code>src</code> and <code>book</code>. <code>src</code> contains the source files, written in <a href="http://commonmark.org/help/">markdown</a>.
When running the tool, it will take all the files in that directory and compile them into the book which is then stored in the <code>book</code> folder.</p>
<p>Finally, the most important file is the <code>SUMMARY.md</code> file. This file represents the table of content of the book, giving the hierarchy of all the
chapters and where to find their source files. The folliwing is an extract from this books summary file.</p>
<pre><code class="language-md"># Summary

[Introduction](introduction.md)
- [Organization](organization/organization.md)
    - [GitHub](organization/github.md)
        - [Administration](organization/gh-admin.md)
    - [mdBook](organization/mdbook.md)
- [Mechanical](mechanical/mechanical.md)
    - [3D modeling with Fusion360](mechanical/fusion.md)
    - [3D printing](mechanical/3d-print.md)
    - [Mecanum wheels](mechanical/mecanum.md)
</code></pre>
<p>We can see that it is simply a set of nested markdown lists containing links to the source files.</p>
<a class="header" href="print.html#markdown" id="markdown"><h2>Markdown</h2></a>
<p>The source files for the book are written in <a href="http://commonmark.org/">Markdown</a>, which is a very simple markup language.
You can <a href="http://commonmark.org/help/">learn the basics in '60 seconds'</a>.</p>
<a class="header" href="print.html#syntax-highlighting" id="syntax-highlighting"><h3>Syntax highlighting</h3></a>
<p>To insert code blocks with syntax heighlighting, use triple backticks followed by the language name / abreviation:</p>
<pre><code>```python
import sys

sys.exit(0)
```
</code></pre>
<p>This will generate the following:</p>
<pre><code class="language-python">import sys

sys.exit(0)
</code></pre>
<a class="header" href="print.html#images" id="images"><h3>Images</h3></a>
<p>In mdBook, paths to images should always be referenced from the <code>src</code> folder. So if you image is located in <code>src/img/my-image.png</code>,
you should use <code>![Some alt text](img/my-image.png)</code>.</p>
<a class="header" href="print.html#generating-the-book" id="generating-the-book"><h2>Generating the book</h2></a>
<p>When you make changes locally, you probably want to see how it looks before making a commit.
You can install the tool for this. At the time of writing, [pre-built binaries] exist for Linux and MacOS,
but not for Windows.</p>
<p>For windows, I have compiled <a href="https://github.com/Ecam-Eurobot/Tutorials/releases/tag/files">a binary</a> that you can use.
You can also <strong>compile mdBook from source</strong>, but this falls outside the scope of this tutorial.</p>
<p>When you have mdBook, add it to your path so that you can use it in the terminal / command line from anywhere.
For this, I will refer you to external documentation: <a href="https://unix.stackexchange.com/questions/26047/how-to-correctly-add-a-path-to-path">Linux / MacOS</a>
&amp; <a href="http://www.itprotoday.com/management-mobility/how-can-i-add-new-folder-my-system-path">Windows</a>.</p>
<p>Now everything is setup, you should be able to open the terminal / command line and type <code>mdbook --help</code> and see the following:</p>
<pre><code>mdBook --help
mdbook v0.1.5
Mathieu David &lt;mathieudavid@mathieudavid.org&gt;
Create a book in form of a static website from markdown files

USAGE:
    mdbook.exe [SUBCOMMAND]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    build    Build the book from the markdown files
    clean    Delete built book
    help     Prints this message or the help of the given subcommand(s)
    init     Create boilerplate structure and files in the directory
    serve    Serve the book at http://localhost:3000. Rebuild and reload on change.
    test     Test that code samples compile
    watch    Watch the files for changes

For more information about a specific command, try `mdbook &lt;command&gt; --help`
Source code for mdbook available at: https://github.com/rust-lang-nursery/mdBook
</code></pre>
<p>The two command that are the most interesting for you are <code>build</code> and <code>serve</code>.</p>
<p>Running <code>mdbook build</code> in the folder where the <code>book.toml</code> is located will generate the book.
The generated book can then be found in the <code>book/</code> folder.</p>
<p>Running <code>mdbook serve</code> is even better, because it will watch the files for any changes and rebuild the book automatically.
On top of that, it serves the book on <code>http://localhost:3000</code> and automatically refreshes the browser after regenerating the book.
You launch it once, when you begin to write and forget about it. It is that simple.</p>
<a class="header" href="print.html#hosting" id="hosting"><h2>Hosting</h2></a>
<p>When you visit the following address: <a href="https://ecam-eurobot.github.io/Tutorials/">https://ecam-eurobot.github.io/Tutorials/</a> you can find this book online.
To host the website, we use GitHub. In the repository of the book, there is a branch called <code>gh-pages</code>. This is a special branch that can be used to host a
static website through GitHub.</p>
<p>When you push a new version of the generated book to this branch, it will be accessible online from the address above.</p>
<blockquote>
<p><strong>Note:</strong><br />
<strong>Don't push manually</strong> to this branch. As explained below, a new version of the book is generated and pushed automatically on each new
commit on the master branch!</p>
</blockquote>
<a class="header" href="print.html#travis" id="travis"><h2>Travis</h2></a>
<p>We have setup <a href="https://travis-ci.org/">Travis</a> to generate the book for each new commit on the master branch. This means that the hosted book is <strong>always</strong>
up to date, with a couple of minutes delay.</p>
<p>The travis configuration file looks like the following:</p>
<pre><code class="language-yaml">sudo: false
dist: trusty
language: rust      # We want to download the Rust toolchain (because mdBook is written in Rust)
cache: cargo        # We want to cache the cargo folder to speed up the compilation of mdBook
rust:
  - stable
branches:
  only:
  - master          # We only want to execute Travis for commits on the master branch
before_script:
  - (cargo install mdbook --vers ^0.1.5 || true)    # Install mdBook (the || true trick is to avoid an error if it is already installed)
script:
- mdbook build      # Generate the book

# Deploy the book to GitHub Pages
deploy:
  provider: pages
  skip-cleanup: true
  github-token: $GH_TOKEN  # Set in travis-ci.org dashboard, marked secure
  keep-history: true
  local-dir: book
  on:
    branch: master
</code></pre>
<a class="header" href="print.html#mechanical" id="mechanical"><h1>Mechanical</h1></a>
<p>As every year, <strong>a big part</strong> of conceiving the robot is <strong>designing the mechanical parts</strong>. The requirements change with the years, but as a big innovation in 2018, we suggest to keep the <a href="mechanical/mecanum.md">Mecanum wheels</a> system. According to the rules, you'll have to <strong>realize</strong> diverse <strong>action</strong> in order to <strong>get points</strong>.</p>
<p>For example, in 2018, the actions were:</p>
<ul>
<li><strong>Collecting blocs</strong>, lift them, sort them according to their color and build a tower with them.</li>
<li><strong>Collecting balls</strong> from a pipe,  sort them by color and evacuate them to a lower position and to a higher one.</li>
</ul>
<p>You'll find more information about the designed mechanisms in the two dedicated chapters (<a href="mechanical/2018/lift.md">Lift</a> &amp; <a href="mechanical/2018/balls.md">Ball mechanism</a>).</p>
<p>Before that, we want to introduce you to one of <strong>our main tools</strong> to design those mechanisms and build them. These are:</p>
<ul>
<li><a href="mechanical/fusion.md">Fusion 360</a>, to design <strong>3D models</strong>.</li>
<li><a href="mechanical/3d-print.md">3D Printing</a>, to <strong>make</strong> the <strong>pieces</strong> we <strong>designed</strong> or <strong>found on the internet</strong> <strong>fast</strong> and <strong>cheap</strong>.</li>
</ul>
<a class="header" href="print.html#a1-getting-in-touch-with-fusion360" id="a1-getting-in-touch-with-fusion360"><h1>1. Getting in touch with Fusion360</h1></a>
<p>Fusion360 is a 3D modeling software used by many professionals and hobbyists to create pieces. You can directly send your models to slicers in order to print them or export the 2D plans to build it your own. The following chapters should give you a global overview of how Fusion360 works and what you can use it for. We'll try to orient our writing to learn your to design in order to print your models later and will end with some tips about the printing them.</p>
<p>To complete your learning we strongly recommend you subscribe to
<a href="https://www.youtube.com/channel/UCo29kn3d9ziFUZGZ50VKvWA">Lars Christensen's Youtube channel</a>.
He's a master in the use of Fusion360 and has very well made videos about every problem or question you might have.</p>
<p>3 videos in particular should hold your attention to get started:
<a href="https://www.youtube.com/watch?v=A5bc9c3S12g">Fusion 360 Tutorial for Absolute Beginners— Part 1</a> and of course
<a href="https://www.youtube.com/watch?v=HXRMzJWo0-Q">Fusion 360 Tutorial for Absolute Beginners— Part 2</a> and
<a href="https://www.youtube.com/watch?v=zS8dYA_Iluc&amp;t=614s">Fusion 360 Tutorial for Absolute Beginners— Part 3</a>.</p>
<p>With all these tools in hands we were able to design our robot: <strong><a href="https://a360.co/2wyML2Z">Cortex</a></strong>.
<img src="img/mechanical/fusion/Cortex_1.PNG" alt="img" /></p>
<a class="header" href="print.html#fusion360-environment" id="fusion360-environment"><h2>Fusion360 environment</h2></a>
<p>The first window you get when opening Fusion360 should be this.</p>
<p>By clicking on <img src="img/mechanical/fusion/square.png" alt="img" /> you access to the repository holding all your folders.
A good practice is to sort them into other repositories according to their relevance. A little bit like you would sort your computer desktop.
<img src="img/mechanical/fusion/FOLDERS.png" alt="FOLDERS" /></p>
<a class="header" href="print.html#project-view" id="project-view"><h2>Project view</h2></a>
<p><img src="img/mechanical/fusion/Fusion1.png" alt="img" /></p>
<p>We'll let you listen to M.Christensen by clicking on the links to the videos we gave earlier to learn the basics of Fusion360. He's an expert on the subject and honestly the only good way to learn this kind of software is by watching someone do and copy. Please don't learn the shortcuts by heart, you'll learn the most used ones by practice.</p>
<a class="header" href="print.html#a2-main-functions-and-shotcuts" id="a2-main-functions-and-shotcuts"><h1>2. Main Functions and Shotcuts</h1></a>
<p>You should already be able to do your first model now, but in case you misted some of the many things explained by Lars, we would like to give you a quick recap.</p>
<p>To start, note that all functions are easily available trough the &quot;s&quot; key shortcut. Just type a word related to what you are searching for and  you'll probably find it directly. <em>Note that you can save them by clicking on the curved arrow.</em></p>
<a class="header" href="print.html#a21-shortcuts" id="a21-shortcuts"><h2>2.1. Shortcuts</h2></a>
<p>Please don't study them, by the way you probably know most of them after  your first hour of practice . If it's still not the case, you'll find them here:</p>
<ul>
<li>S=Model Toolbox</li>
</ul>
<ul>
<li>L=Line</li>
<li>C=Circle</li>
<li>X=Construction</li>
<li>D=Dimension</li>
</ul>
<ul>
<li>Q=Push/Pull</li>
<li>M=Move</li>
<li>J=Joint</li>
<li>T=Trim (delete lines)</li>
</ul>
<ul>
<li>Middel button of your mouse = Pan</li>
<li>Maj+ middel button  = 3D move</li>
</ul>
<a class="header" href="print.html#a22-useful-functions" id="a22-useful-functions"><h2>2.2. Useful functions</h2></a>
<a class="header" href="print.html#offset" id="offset"><h3>Offset</h3></a>
<p>Offset is a very handy tool when it comes to drawing parallel lines.
<img src="img/mechanical/fusion/Offset1.png" alt="img" /></p>
<p>The tools works only in sketch mode and you have to already have a reference line (or a shape).
Type the &quot;o&quot; key to open the &quot;offset menu&quot;, you then have to select the reference line you want.
You can either drag and drop the cursor with your mouse or type the value you wish the offset to be.
<img src="img/mechanical/fusion/Offset_drag.png" alt="img" />
<img src="img/mechanical/fusion/OFFSET_VALUE.png" alt="img" /></p>
<p>You'll end with the line/shape you selected offset as you wanted.
<img src="img/mechanical/fusion/Offset_finish.png" alt="img" /></p>
<a class="header" href="print.html#sweep" id="sweep"><h3>Sweep</h3></a>
<p>Another useful tool to make pipe, slide and so on is the &quot;sweep&quot; function. Start by drawing a sketch on a
face. In our example it's going to be a double circle.
<img src="img/mechanical/fusion/Sweep_1.PNG" alt="img" /></p>
<p>Then close your current sketch. Go to another face. Start a new sketch . Use &quot;spine&quot; for example and draw a line following as much point as you want.
<img src="img/mechanical/fusion/Sweep_2.PNG" alt="img" /></p>
<p>You'll be able now to use &quot;Sweep&quot;, select the space between the two circle as &quot;profile&quot;, select the line as &quot;path&quot; and you'll automatically make a curved pipe!
<img src="img/mechanical/fusion/Sweep_3.PNG" alt="img" /></p>
<p>We used it for example for the <a href="https://a360.co/2Jzo4oP">slide</a> in the 2018's ball mechanism.</p>
<a class="header" href="print.html#revolve" id="revolve"><h3>Revolve</h3></a>
<p>Revolve allows you to create objects as if you turned them on a lathe. It comes in handy to make wheels, cannons, ...
To used it you have to first create a shape around an axis. When you create that shape, you have to imagine it round. So you only have to draw &quot;a half cut of your future object&quot;.
<img src="img/mechanical/fusion/Vase_shape.png" alt="img" /></p>
<p>Type &quot;s&quot; to access the &quot;search menu&quot; and enter &quot;revolve&quot; to find the tool. You'll have to select the shape and the axis you want and press &quot;enter&quot;.
<img src="img/mechanical/fusion/vase_glass.png" alt="img" /></p>
<a class="header" href="print.html#appearance" id="appearance"><h3>Appearance</h3></a>
<p>To make design easier for others to imagine or simply to choose colors and material purely esthetically, the &quot;Appearance&quot; tool is a must! You can archive more or less the same result with the &quot;Physical Material&quot; tool, but this is more often used for simulation. You can also combine those tools to get for example a steel pipe covered in leather without having to create the wrapping in a new component.
It is also very handy when creating complex assemblies with little pieces because the different appearances help to see those different pieces.</p>
<p>Appearance is really easy to use. Type &quot;a&quot;, choose the look you like and drag-drop it on the body you want. You can directly drop it in the project tree or on the visual objet.<br />
<img src="img/mechanical/fusion/Appearance_tool.png" alt="img" /></p>
<a class="header" href="print.html#pattern" id="pattern"><h3>Pattern</h3></a>
<p>Real time savior, &quot;Pattern&quot; allows you to duplicate sketches, bodies and components on a given distance.
Multiple pattern tools exists. To see then go into the &quot;search menu&quot; and type &quot;Pattern&quot;.
<img src="img/mechanical/fusion/multiple_patterns.png" alt="img" /></p>
<p>As you can see in the above picture, you can create a circular, rectangular or &quot;free style&quot; pattern.
For both rectangular and circular patterns the ones with white square create patterns in sketches. The grey ones create patterns of volumes (bodies, components). We'll only present the sketch pattern, but the volumes work in a similar way.</p>
<a class="header" href="print.html#rectangular-pattern" id="rectangular-pattern"><h4>Rectangular pattern</h4></a>
<p><img src="img/mechanical/fusion/Pattern_open.png" alt="img" /></p>
<p>To apply rectangular patterns, select the desired shape and the amount of copies you want in the 2 directions. You can then enter (or drag-drop) the distance on which you want to copy that shape for both directions and click &quot;ok&quot;.
<img src="img/mechanical/fusion/Rect_patt_1side.png" alt="img" />
<img src="img/mechanical/fusion/Rect_patt_2side.png" alt="img" />
<img src="img/mechanical/fusion/Rect_pattern_done.png" alt="img" /></p>
<a class="header" href="print.html#circular-pattern" id="circular-pattern"><h4>Circular pattern</h4></a>
<p>Circular patterns work in a similar way accept the fact you have to choose a center point and you can choose to make a complete revolution around it, or on a given angle.
<img src="img/mechanical/fusion/circ_patt-full.png" alt="img" />
<img src="img/mechanical/fusion/circ_patt_angle.png" alt="img" /></p>
<p><em>Note that it's also possible to draw a path and then follow it with our pattern.</em></p>
<a class="header" href="print.html#mirror" id="mirror"><h3>Mirror</h3></a>
<p>Available in sketch and also in 3D, the &quot;Mirror&quot; tool is very useful to create quickly twice the same things symmetrically from a line or a plane.</p>
<p>For the 3D tools, start by drawing your piece, in this case a notch to close a wall.
<img src="img/mechanical/fusion/Mirror_1.PNG" alt="img" /></p>
<p>Use the Mirror tool, select the faces that you want to copy and then the plane.
<img src="img/mechanical/fusion/Mirror_2.PNG" alt="img" />
<em>Note that if you select only the top face of your notch you won't be able to copy it because the program doesn't allow you to create a new face in the empty space. You have to select all the three faces of your notch.</em></p>
<p><img src="img/mechanical/fusion/Mirror_3.PNG" alt="img" /></p>
<p>As we said, it's also available in sketch mode. So if you want to make two holes symmetrically. Just draw a circle. Draw a construction line that we'll use as our center line. Chose the distance from the center line, then select &quot;Mirror&quot;. Select the circle as &quot;Object&quot; and in the &quot;Mirror line&quot; select the construction line
<img src="img/mechanical/fusion/Mirror_4.PNG" alt="img" />
<img src="img/mechanical/fusion/Mirror_5.PNG" alt="img" /></p>
<p>We can now make our two holes. Select the two of them (by holding  &quot;ctrl&quot; pressed down) and then cut them through the bodie.
<img src="img/mechanical/fusion/Mirror_6.PNG" alt="img" /></p>
<a class="header" href="print.html#fillet" id="fillet"><h3>Fillet</h3></a>
<p>As you used it in Autocad or similars, fillet allows you to joint two lines to make a curve.
In Fusion 360, as a 3D software, you'll also find the possibility to &quot;curve&quot; your 3D body.
<img src="img/mechanical/fusion/Fillet_1.PNG" alt="img" /></p>
<figure>
  <figcaption>Fig. - First Fillet is for sketch and the second one for 3D model.</figcaption>
</figure>
<p>To use the sketch fillet, just select it and then click on the two lines to join.
<img src="img/mechanical/fusion/Fillet_2.PNG" alt="img" /></p>
<p>In the 3D model, just select the edge and with the arrow or value chose the radius of your fillet.
<img src="img/mechanical/fusion/Fillet_3.PNG" alt="img" />
<img src="img/mechanical/fusion/Fillet_4.PNG" alt="img" /></p>
<a class="header" href="print.html#chamfer" id="chamfer"><h3>Chamfer</h3></a>
<p>In the same way of thinking than for fillet, you'll have the possibility to make a chamfer.
<img src="img/mechanical/fusion/Chamfer_1.PNG" alt="img" />
Select the tools and click on the edge.
<img src="img/mechanical/fusion/Chamfer_2.PNG" alt="img" />
You'll also be able to do it with a curved edge (the one made with fillet)
<img src="img/mechanical/fusion/Chamfer_3.PNG" alt="img" />
<img src="img/mechanical/fusion/Chamfer_4.PNG" alt="img" />
<em>Note that in this case you'll be limited by the angle of the previous made fillet.</em></p>
<p>Another option is to change the &quot;Chamfer type&quot; and select &quot;Distance and angle&quot; to make a chamfer with a selected angle.
<img src="img/mechanical/fusion/Chamfer_5.PNG" alt="img" /></p>
<a class="header" href="print.html#join" id="join"><h3>Join</h3></a>
<p>A joint is a link between two pieces that describes the way they move one on the other. It comes in handy when describing actions to external people, or when modeling pieces in an assembly to avoid collisions due to design mistakes.
To create joints, you have to first <strong>ground components</strong>. By grounding components you avoid them to move, and so you can use them as a static reference. Take <em>Cortex</em> for example, the base has been grounded and all the rest around him has been jointed.
<img src="img/mechanical/fusion/cortex.png" alt="img" /></p>
<p>This means you can not drag it around. The second thing you have to do is <strong>create rigid groups</strong>. By searching for &quot;rigid group&quot; when hitting the &quot;s&quot; key you will enter the &quot;rigid group&quot; menu. You can now select all the component that should move together. You'll still be able to drag them around, but only as one group and not separately anymore. This is for example the case for the mecanum wheels as you can not move their different pieces separately.
After this is done, we can now <strong>join modules together</strong> ('j' key). To do so select the points of the modules that will touch after jointing starting with the one you want to be able to move.
<img src="img/mechanical/fusion/joint_face1.png" alt="img" />
<img src="img/mechanical/fusion/joint_face2.png" alt="img" /></p>
<p>After this is done you can select the type of joint you want and the axis along which to movement will have to be.
<img src="img/mechanical/fusion/joint_type.png" alt="img" />
<img src="img/mechanical/fusion/joint_defined.png" alt="img" /></p>
<p>After confirming the settings, you can right-click on the joint to edit the joints limits and inverse the natural movement.
<img src="img/mechanical/fusion/joint_limit.png" alt="img" /></p>
<p>To learn more about jointing component click on the link to Lars's video about that topic
<a href="https://www.youtube.com/watch?v=KQNgIfjMr84">Fusion 360 Tutorial — How to get a handle on Assembly and Joints in Fusion</a>.</p>
<a class="header" href="print.html#a3-3d-design-export-to-plan-or-3d-slicer" id="a3-3d-design-export-to-plan-or-3d-slicer"><h1>3. 3D Design export to plan or 3D Slicer</h1></a>
<a class="header" href="print.html#a31-design-export-as-drawing" id="a31-design-export-as-drawing"><h2>3.1. Design export as drawing</h2></a>
<p>One of the main reason you have to make a 3D model before starting the actual build of your project is the ease you get to make 2D plan you can send to a manufacture or use to build the pieces your own. Making this plans will save you a lot of time and material because all the testing on designs is made virtually and not with physical materials you have to buy, cut, test, re-cut , etc... To extract the plans of the design you made, right-click on the component you want and select &quot;create drawing&quot;.
<img src="img/mechanical/fusion/drawing_start.png" alt="img" /></p>
<p>A window pops up to specify the parts you want to include in the drawing and the format of the destination sheet (<strong>be careful on that</strong>) select the piece and click &quot;ok&quot;.
<img src="img/mechanical/fusion/drawing_drop.png" alt="img" /></p>
<p>A widget is automatically created and the component is now attached to your mouse. Notice that in the small window that comes with the widget you can select the view and scale you want to use. After dropping the component and clicking &quot;ok&quot; on the small window your drawing is fully generated and you can start editing it.
<img src="img/mechanical/fusion/drawing_dimension.png" alt="img" /></p>
<p>By hitting the &quot;d&quot; key you can start indicating the dimensions you want to specify. Save to PDF and your done.</p>
<a class="header" href="print.html#a32-export-3d-design--3d-printing" id="a32-export-3d-design--3d-printing"><h2>3.2. Export 3D design  (3D printing)</h2></a>
<p>Now comes the fun part: 3D printing your own designs. You'll see that it is really satisfying to see something you designed your own &quot;come to live&quot; in the printer and to do so you will have to export you design as an '.stl' file.</p>
<p>First start by hitting the &quot;make&quot; icon in the top bar.
<img src="img/mechanical/fusion/make_icon.png" alt="img" /></p>
<p>It will open a window asking you to select the component you want to print and where you want to send the stl file. As you might expect you have to click on the body or component you want to print (<strong>One at the time!</strong>). As most printers have an accuracy only as good as their nozzle diameter, an assembly will always be printed as one bloc! For that reason we recommend to only select bodies when printing an assembly. It takes more time to print, but if the pieces have to move their is no other way to avoid monolithic prints.</p>
<p>Now comes the moment you have to choose between sending your design to a facility (and generating an stl file) or printing it from your computer and send it to a slicer software (up studio for the small printer in ECAM's electronic lab, Ultimaker Cura, Repetier-host, etc...).
<img src="img/mechanical/fusion/3Dprint_select_body.png" alt="img" /></p>
<p>To <strong>create an stl file</strong> unselect &quot;Send to 3D print utility&quot; and select ok.</p>
<p>To <strong>3D print it from your computer</strong> select &quot;Send to 3D print utility&quot; and link your slicer software by clicking on the folder icon. When the slicer is linked click &quot;ok&quot; and launch the print form your slicer that will have been open and loaded with the design by Fusion360.</p>
<a class="header" href="print.html#a4-design-import-and-modification" id="a4-design-import-and-modification"><h1>4. Design import and modification</h1></a>
<p>As you probably know there are tons of CAD drawings already made that can often help you in your designs.
You'll find them on different formats but in general, all of them can be open with fusion or a slicer to print them.</p>
<p>The best known databases are:</p>
<ul>
<li><a href="https://grabcad.com/library">GrabCAD</a></li>
<li><a href="https://www.thingiverse.com/">Thingiverse</a></li>
</ul>
<p>In <a href="https://grabcad.com/library">GrabCAD</a>, you'll find <em>.stp</em>, <em>.sta</em>, <em>.SLDPRT</em> files that you'll have to send into fusion to modify them and then send them in your slicer. You'll find really useful and complex design to add to yours to verify dimension and so on.
We used it for example for our <a href="https://a360.co/2wFFzCj">Home Automation Panel</a> during the 2018 Edition, where the design of the <a href="https://grabcad.com/library/lcd-screen-16x2-1">LCD</a>, the <a href="https://grabcad.com/library/arduino-uno-18">Arduino</a> and the <a href="https://grabcad.com/library/motor-gear-box-4">motor</a> really helped us to fix the dimensions of the panel.</p>
<p>When you'll have the file that you want to implement in Fusion, just click on the upload button (top-left corner, on the project panel).</p>
<p><em>Always use this method instead of opening the file with fusion directly or it will make errors during the conversion</em>
<img src="img/mechanical/fusion/Upload_1.PNG" alt="img" />
<img src="img/mechanical/fusion/Upload_2.PNG" alt="img" /></p>
<p>You now have the possibility to link these new designs into yours. Just open the main design to see it, right-click on the secondary design and &quot;Insert Into Current Design&quot;. The now linked component will be shown with some chain link on it.
<img src="img/mechanical/fusion/Upload_3.PNG" alt="img" /></p>
<p>In <a href="https://www.thingiverse.com/">Thingiverse</a>, you'll find <em>.stl</em> files, already thought for the 3D printing, with some tips on how to print them sometimes.</p>
<p>It's also possible to modify them with the <a href="https://www.youtube.com/watch?v=-IE7kKxdTFY">following steps</a>.</p>
<hr />
<a class="header" href="print.html#contributors" id="contributors"><h2>Contributors</h2></a>
<ul>
<li>Puissant Baeyens Victor, 12098, <a href="https://github.com/MisterTarock">MisterTarock</a></li>
<li>De Decker William, 14130, <a href="https://github.com/WilliamHdd">WilliamHdd</a></li>
</ul>
<a class="header" href="print.html#a1-how-to-think-3d-printing" id="a1-how-to-think-3d-printing"><h1>1. How to think 3D printing</h1></a>
<p>Now that you know how to design in 3D and export your file to a slicer, we'll take you straight to the world of the 3D printing. We'll see his amazing abilities but also his limitations.</p>
<a class="header" href="print.html#a11-think-mechanical-properties" id="a11-think-mechanical-properties"><h2>1.1. Think &quot;mechanical properties&quot;</h2></a>
<p>When you'll have to create a mechanical piece for your robot, you have to think about the way you'll use it.
For example, if it's a piece that will be in contact with water, a lot of people will have the tendency to say: &quot;You have to use ABS!&quot;
Right now there are other possibilities as the PETG that have similar properties but has less warping. Each one of them have their advantages and their defaults.
It's true that the ABS will have better mechanical resistance against wear and tear than PLA but you'll have to pay more attention at the temperature variation and the wrapping problems.
That's only the top of the iceberg for the materials, if you're interested by knowing more about it, you can still find a lot on the web on divers site like: <a href="http://www.primante3d.com/materiaux/">Primant3D</a>.</p>
<p>Another simple tip is to think about the way the fibers during the use of the pieces.
As you can see on this piece, a Pelton wheel , at first the shaft and the wheel were design as in one piece.
<img src="img/mechanical/3d-print/Pelton_wheel_1.PNG" alt="img" /></p>
<p>After thought, as the shaft will have to oppose strength in the radial way, it's way more efficient to print it horizontaly than verticaly (where the layers would detache).
For the wheel, it's the opposite. The spoons have to go against strength in the perpendicular way, so it had to be printed also horizontal, laying on the bed.
It was then decided to print them in two pieces.
<img src="img/mechanical/3d-print/Pelton_wheel_2.PNG" alt="img" /></p>
<a class="header" href="print.html#a12-think-about-the-supports" id="a12-think-about-the-supports"><h2>1.2. Think about the supports</h2></a>
<p>As you'll see in the point <strong>3. Printer Configuration</strong>, there are a lot of different parameters to take into account. In this point, we'll speak about the supports, their necessity and their troubles.
As you can see on the picture below, there a lots of support placed to help the printer. As the print is done layer by layer, it needs supports to help the extrusion of part on empty space.
<img src="img/mechanical/3d-print/Support_1.PNG" alt="img" />
<em>Note that you'll have to be in layer view to see them (Top-Right Corner)</em></p>
<p>The most used to tune your print is the <strong>Overhang Angle</strong>, it will allow you to control the amount and place of the supports.
<img src="img/mechanical/3d-print/Support_2.PNG" alt="img" /></p>
<p>The use of limiting the amount of support is to reduce waste, reduce printing time (in this case 1h45) but also cleaning time as you'll have to cut or tear them apart by hand. There is a possibility with dual extrusion to print them with PVA (water soluble filament) but it requires a more expensive printer.</p>
<p>However, I recommend to try the parameters shown on the picture because they make the removing of supports way easier than the default one.</p>
<a class="header" href="print.html#a13-think-about-the-face-laying-on-the-heat-bed" id="a13-think-about-the-face-laying-on-the-heat-bed"><h2>1.3. Think about the face laying on the heat bed</h2></a>
<p>As said before, the printer will often need support, but the orientation of the piece on the bed will also help a lot to reduce them.
In this piece, simply by laying it on one face, you'll remove all the need for support.
<img src="img/mechanical/3d-print/Bed_1.PNG" alt="img" />
<img src="img/mechanical/3d-print/Bed_2.PNG" alt="img" /></p>
<p>In this case, it would be absurd to put it on the other face as it will require a lot of support and their will be very complex to remove.
<img src="img/mechanical/3d-print/Bed_3.PNG" alt="img" /></p>
<p>On this final picture, imagine many of this cubes needing to be plugged one in another and that have to be printed on their left face.
You can use two different design:</p>
<ul>
<li>In the first design (the two top cube) the top-left one will require support.</li>
<li>In the second design (the two cube below) the low-left one can be printed easily.</li>
</ul>
<p>More, in the second design, all the cube are the same so you can print a lot of them really fast.
<img src="img/mechanical/3d-print/Bed_4.PNG" alt="img" /></p>
<a class="header" href="print.html#a2-what-printer-to-choose" id="a2-what-printer-to-choose"><h1>2. What printer to choose?</h1></a>
<p>The offer in mater of 3D printers is enormous and can be confusing to an unexperimented printer.
And even if you know what you are looking for, you can find the same looking printer for at least 10 different prices and brands.
As a matter of fact a lot of companies copy the &quot;big ones&quot; and sale these copies a lot cheaper.
These copies can be a very good investment for non-professional work and can save you quite a few euros, but can also be a real nightmare.</p>
<p>A general advice is to read as many reviews as possible and to try to choses a printer that a lot of people have. Isolated brands are often isolated for a very good reason (quality issues for example) and you'll struggle finding informations on settings, performances and things like parts to print to upgrade you printer.</p>
<p>The Anet company for example is very popular brand that sells versions of open source printers.
The are close to the cheapest you can find, but have very decent quality and high liability.
Hereby lots of people have one and you can find tones of parts on
<a href="https://www.thingiverse.com/search/page:1?q=Anet+A8&amp;sa=&amp;dwh=525af4b8e015a6f">Thingiverse AnetA8</a> to upgrade their models.</p>
<p>Other companies like FLSUN sale some of the same open source models (prusa i3) a like more expensive but are less reliable and upgrade parts are pretty difficult to find.</p>
<p>So what to chose ?</p>
<p>Well we are not going to give you a list of printers to buy or not to buy, but we'll try to give you guidelines to follow when comparing what the market offers.</p>
<a class="header" href="print.html#a21-technologies" id="a21-technologies"><h2>2.1. Technologies</h2></a>
<p>Men have developed different ways to 3D print stuff, each and every one of it with its own advantages.
The cheapest and thus most used is the extrusion of molten plastic, but others like resin printing (where a laser hits a bath of liquid resin hardening it instantly) or metal printing (same idea as for resin but with a bath of metal powder), are starting to emerge. These however are really expensive (2 000$ up to hundreds of thousands of dollars for the machine only) for the moment and won't be discussed any further.</p>
<p>The rest of this document will so only speak about plastic extrusion printing.</p>
<a class="header" href="print.html#a22-structure-of-the-printer" id="a22-structure-of-the-printer"><h2>2.2. Structure of the printer</h2></a>
<p>You'll find two main types of structures: cartesian and delta.
<img src="img/mechanical/3d-print/Cartesian-3D-printer.jpg" alt="img" /></p>
<p>Delta 3D printers were designed for speed, but they also have the distinction to have a print bed that never moves, which may come in handy for certain print jobs.
In the other hand, their speed comes with a certain weakness for details and a lack in precision.</p>
<p>Cartesian printers are better for details and easier to build and maintain, but slower.</p>
<a class="header" href="print.html#a23-precision" id="a23-precision"><h2>2.3. Precision</h2></a>
<p>As you might expect, cheap printers (100€-400€) don't have the same accuracy as semi-professional ones that cost about 2000€-5000€ (Ultimakers for example).
This can be scaring at first, but think about it this way: do you really need to print at a resolution of 20 microns (an aluminum sheet is about 16 microns )?
For most of the prints you'll make a precision of 0,2mm and a little bit of sanding is more than enough.
You can find more than decent printers for around 200€ (Anet A6) for medium bed sizes.
Larger bed printers will cost about 300€ (Creality3D CR - 10).
Note that these printers are DIY printers so you'll have to assemble them your own.
This might take a few days, but is a piece of cake with the manual and will save you a few hundred euros.</p>
<a class="header" href="print.html#a24-links" id="a24-links"><h2>2.4. Links</h2></a>
<p>To close the subject, here are some links you could find handy in your search of a 3Dprinter to acquire or to improve.</p>
<ul>
<li><a href="https://www.thingiverse.com/search/page:1?q=Anet+A8&amp;sa=&amp;dwh=525af4b8e015a6f">Thingiverse AnetA8</a></li>
<li><a href="http://www.instructables.com/id/Transform-a-chinese-3D-printer-in-a-high-precision/">Instructables improvement</a></li>
<li><a href="http://www.fabbaloo.com/blog/2015/11/11/bowden-or-direct-a-primer-on-extruder-styles">Choose between a Bowden or Direct extruder</a></li>
<li><a href="https://pevly.com/anet-a8-vs-a6/">Anet A8 vs A6</a></li>
<li><a href="http://www.instructables.com/id/2000-Quality-Prints-From-a-200-Printer-an-Upgrade-/">Anet A8 improvement</a></li>
</ul>
<!-- si tu veux rajouter des liens -->
<a class="header" href="print.html#a3-printer-configuration" id="a3-printer-configuration"><h1>3. Printer Configuration</h1></a>
<p>There are tons of different parameters that will influence the quality of your print.
It would be out of the topic to list them all but we encourage you to read the following document to calibrate your printer as good as possible.</p>
<ul>
<li><a href="mechanical/References/A6_Parameters_Cura.pdf">Cura's parameters for Anet A6</a></li>
<li><a href="mechanical/References/Print_Quality_Troubleshooting_Guide-Anet.pdf">Print Quality Troubleshooting Guide Anet</a></li>
<li><a href="http://www.primante3d.com/curling-29082016/">Warpping problems</a></li>
</ul>
<a class="header" href="print.html#a4-some-tips-before-printing" id="a4-some-tips-before-printing"><h1>4. Some tips before printing</h1></a>
<p>The Ultimaker 2+ is the printer that we are using for our 3D model.
Before using the printer, there are some points to check :</p>
<ol>
<li>The filament</li>
</ol>
<ul>
<li>Is it a PLA ?</li>
<li>Is it a 2.85 mm width ?</li>
<li>Isn’t it stuck ?</li>
<li>Is it in the right position?</li>
</ul>
<p><img src="img/printer/filament.jpg" alt="img" /></p>
<ol start="2">
<li>The build plate</li>
</ol>
<ul>
<li>Placement, adjust it accordingly (follow the instructions on the printer)</li>
<li>They may have some adherence issues, the trick is to use glue on the plate</li>
</ul>
<p>When you lunch the printing, always wait for the 1 layer before leaving, it may have some adjustment error or filament can be stuck.</p>
<a class="header" href="print.html#troubleshooting" id="troubleshooting"><h2>Troubleshooting</h2></a>
<p>If the filament is stuck, it doesn't come out, stop the printing.<br />
It may happen because :</p>
<ul>
<li>The filament is stuck and it can't feed the printer</li>
<li>The nozzle is clogged</li>
</ul>
<p>If the nozzle is clogged try the <a href="https://www.youtube.com/watch?v=04T8zdgyh3E">Atomic solution</a></p>
<p>Else try https://ultimaker.com/en/resources/11704-extrusion-problems</p>
<hr />
<a class="header" href="print.html#contributors-1" id="contributors-1"><h2>Contributors</h2></a>
<ul>
<li>Puissant Baeyens Victor, 12098, <a href="https://github.com/MisterTarock">MisterTarock</a></li>
<li>De Decker William, 14130, <a href="https://github.com/WilliamHdd">WilliamHdd</a></li>
<li>Ping Tian-sen 16333</li>
</ul>
<a class="header" href="print.html#mecanum-wheels" id="mecanum-wheels"><h1>Mecanum wheels</h1></a>
<p><img src="img/mechanical/mecanum/mecanum.jpg" alt="" /></p>
<p>A mecanum wheel is a wheel with rollers attached at its circumference at an angle of typically 45°.
When four mecanum wheels are used together, we can achieve a net resulting direction in <strong>any</strong> direction by varying the direction and speed of rotation of the wheels.</p>
<a class="header" href="print.html#assembly" id="assembly"><h2>Assembly</h2></a>
<a class="header" href="print.html#wheel-adapter" id="wheel-adapter"><h3>Wheel adapter</h3></a>
<p>To mount the wheels onto the motors, we need to use an adapter.
Due to an error in our order, we didn't receive the correct adapters and the ones we received didn't fit on the wheels.</p>
<p>We decided to 3D print our own as a replacement. The <a href="">STL file for this part can be found here</a>.</p>
<blockquote>
<p><strong>Note:</strong><br />
3D printing parts that will be under moderate or heavy mechanical stress is often not the best idea, because those parts will tend to break and/or wear out quickly.</p>
</blockquote>
<a class="header" href="print.html#wheel-orientation" id="wheel-orientation"><h3>Wheel orientation</h3></a>
<p>When assembling the wheels onto the robot, we need to pay attention to their orientation.
If we look from the top view, the rollers should all point to the center of the base.</p>
<p><img src="img/mechanical/mecanum/mecanum-orientation.png" alt="" /></p>
<a class="header" href="print.html#kinematics" id="kinematics"><h2>Kinematics</h2></a>
<p><strong>Forward kinematics</strong> refers to the use of the kinematic equations of a robot to compute the position of the end-effector from specified values for the joint parameters. In our case, the forward kinematics allow us to compute the global velocity of the robots base when given the angular velocities of the individual wheels.</p>
<p>The reverse process that computes the joint parameters that achieve a specified position of the end-effector is known as <strong>inverse kinematics</strong>. The inverse kinematic equations allow us, in our case, to compute the individual wheel velocities needed to achieve a given base velocity.</p>
<p>The equations presented in the next sections come from the following research paper: <a href="https://research.ijcaonline.org/volume113/number3/pxc3901586.pdf">&quot;Kinematic Model of a Four Mecanum Wheeled Mobile Robot&quot;</a></p>
<a class="header" href="print.html#inverse-kinematics" id="inverse-kinematics"><h3>Inverse kinematics</h3></a>
<p>The inverse kinematic equations allow us to compute the indiviual wheel velocities when we want to achieve an overall base velocity.</p>
<ul>
<li>\(\omega_{fl}\), \(\omega_{fr}\), \(\omega_{rl}\) and \(\omega_{rr}\)  represent the <em>angular velocities</em> for the front left, front right, rear left and rear right wheel respectively.</li>
<li>\(v_x\) and \(v_y\) represent the robot's base linear velocity in the x and y direction respectively. The x direction is in front of the robot.</li>
<li>\(\omega_z\) is angular velocity of the robot's base around the z-axis.</li>
<li>\(l_x\) and \(l_y\) represent the distance from the robot's center to the wheels projected on the x and y axis respectively.</li>
</ul>
<!-- MathJax math equation -->
\[
    \left\{\begin{matrix}
    \omega_{fl} &= \frac{1}{r} \left[v_x - v_y - (l_x + l_y)\omega_z \right ] \\ 
    \omega_{fr} &= \frac{1}{r} \left[v_x + v_y + (l_x + l_y)\omega_z \right ] \\ 
    \omega_{rl} &= \frac{1}{r} \left[v_x + v_y - (l_x + l_y)\omega_z \right ] \\ 
    \omega_{rr} &= \frac{1}{r} \left[v_x - v_y + (l_x + l_y)\omega_z \right ] 
    \end{matrix}\right.
\]
<p>Or in matrix form:</p>
<!-- MathJax math equation -->
\[
    \begin{bmatrix}
    \omega_{fl} \\ 
    \omega_{fr}\\ 
    \omega_{rl}\\ 
    \omega_{rr}
    \end{bmatrix}
    =
    \frac{1}{r}
    \begin{bmatrix}
    1 & -1 & -(l_x + l_y) \\ 
    1 &  1 &  (l_x + l_y) \\ 
    1 &  1 & -(l_x + l_y) \\ 
    1 & -1 &  (l_x + l_y)
    \end{bmatrix}
    \begin{bmatrix}
    v_x\\ 
    v_y\\ 
    \omega_z
    \end{bmatrix}
\]
<a class="header" href="print.html#example" id="example"><h4>Example</h4></a>
<p>If we want to let the robot move diagonally at <code>0.22 m/s</code> in the x direction and <code>0.11 m/s</code> in the y direction. At what speed should we set the motors of each wheel?</p>
<p>The robot is 15 cm in width and 20 cm in length. The wheels are placed at the extremities and have a diameter of 60 mm.</p>
<hr />
<!-- MathJax math equation -->
\[
    \left\{\begin{matrix}
    \omega_{fl} &= \frac{1}{0.03} \left[0.22 - 0.11 - (0.2 + 0.15) \cdot 0 \right ] = 3.66 \; rad / s\\ 
    \omega_{fr} &= \frac{1}{0.03} \left[0.22 + 0.11 + (0.2 + 0.15) \cdot 0 \right ] = 11 \; rad / s \\ 
    \omega_{rl} &= \frac{1}{0.03} \left[0.22 + 0.11 - (0.2 + 0.15) \cdot 0 \right ] = 11 \; rad/s \\ 
    \omega_{rr} &= \frac{1}{0.03} \left[0.22 - 0.11 + (0.2 + 0.15) \cdot 0 \right ] =  3.66 \; rad/s
    \end{matrix}\right.
\]
<hr />
<a class="header" href="print.html#forward-kinematics" id="forward-kinematics"><h3>Forward kinematics</h3></a>
<p>The forward kinematic equations allow us to compute the robot's base velocity when given the individual wheel velocities. This is usefull to compute the robot's odometry using the motor's embedded quadrature encoders.</p>
<p><em>Odometry is the use of sensor data to estimate the change in position of the robot over time.</em></p>
<!-- MathJax math equation -->
\[
    \left\{\begin{matrix}
    v_x & = (\omega_{fl} + \omega_{fr} + \omega_{rl} + \omega_{rr}) \cdot \frac{r}{4}\\ 
    v_y & = (-\omega_{fl} + \omega_{fr} + \omega_{rl} - \omega_{rr}) \cdot \frac{r}{4}\\ 
    \omega_z & = (-\omega_{fl} + \omega_{fr} - \omega_{rl} + \omega_{rr}) \cdot \frac{r}{4(l_x + l_y)}
    \end{matrix}\right.
\]
<p>Or in matrix form:</p>
<!-- MathJax math equation -->
\[
    \begin{bmatrix}
    v_x\\ 
    v_y\\ 
    \omega_z
    \end{bmatrix}
    =
    \frac{r}{4}
    \begin{bmatrix}
    1 & 1 & 1 & 1\\ 
    -1 & 1 & 1 & -1\\ 
    -\frac{1}{(l_x+l_y)} & \frac{1}{(l_x+l_y)} & -\frac{1}{(l_x+l_y)}  & \frac{1}{(l_x+l_y)} 
    \end{bmatrix}
    \begin{bmatrix}
    \omega_{fl}\\ 
    \omega_{fr}\\ 
    \omega_{rl}\\ 
    \omega_{rr}
    \end{bmatrix}
\]
<a class="header" href="print.html#code" id="code"><h2>Code</h2></a>
<p>For an implementation of the mecanum wheels in the code, refer to chapter: <a href="software/mecanum/mecanum.html">Mecanum wheels in software</a></p>
<a class="header" href="print.html#vacuum-prehention" id="vacuum-prehention"><h1>Vacuum prehention</h1></a>
<p>To take the pucks, we use a vacuum system.</p>
<p>The material list:</p>
<ul>
<li>pump</li>
<li>valve</li>
<li>suction cup</li>
</ul>
<p>The material is from Festo (we can have good price for student projetcs)</p>
<p><img src="img/mechanical/vacuum/Cablage_Festo.jpg" alt="Cablage" /></p>
<p><img src="img/mechanical/vacuum/Schematic_Festo.png" alt="Schematic" /></p>
<p>Other prehention systems were use to take the pucks of the 2019 contests: like shovel.</p>
<a class="header" href="print.html#pros" id="pros"><h2>Pros</h2></a>
<ul>
<li>mechanism is easy to take flat surface</li>
</ul>
<a class="header" href="print.html#cons" id="cons"><h2>Cons</h2></a>
<ul>
<li>the pump use lot of power</li>
<li>the pump and the valve take lot of space</li>
</ul>
<a class="header" href="print.html#a2018-specifics" id="a2018-specifics"><h1>2018 Specifics</h1></a>
<p>In 2018, the two big mechanical tasks were:</p>
<ol>
<li><strong>Collect cubes</strong> that are distributed at specific locations on the playing field. The collected blocks then need to be stacked
to create a tower. For each story (level), a bigger amount of points were given. Additionally, if the tower contained
the 3 cube séquence, revealed at the beginning of the match, additionnal points were earned.</li>
<li><strong>Collect foam ping-pong balls</strong> from the dispensers. The robot first has to open the lock so that the balls can fall out
of the dispenser. Then the robot had to sort the balls and, depending on their color, either shoot them into a &quot;tower&quot;
or put them in another recipient.</li>
</ol>
<p><img src="img/mechanical/2018/table.jpg" alt="Playing field" /></p>
<a class="header" href="print.html#the-big-robot-specifications" id="the-big-robot-specifications"><h1>The big robot specifications</h1></a>
<p><img src="mechanical/2018/bigrobot_render.PNG" alt="alt text" /></p>
<a class="header" href="print.html#fusion-360" id="fusion-360"><h2>Fusion 360</h2></a>
<p>The entire robot is designed in Fusion 360 and is available on the Eurobot cloud. The final version is called <strong>SHARK FINAL V17</strong></p>
<p>Here is the link to download de fusion projet : <a href="https://a360.co/2wA0er0">BigRobotModel</a></p>
<a class="header" href="print.html#the-goal-of-the-2018-edition" id="the-goal-of-the-2018-edition"><h2>The goal of the 2018 edition</h2></a>
<p><img src="mechanical/2018/bigRobotSrc/plan_arene.PNG" alt="alt text" /></p>
<p>The robot starts from the inital surface (<strong>number 1</strong>).</p>
<p>The robot has to collect the cubes and to build a tower of 5 cubes maximum in the construction zone (<strong>number 4</strong>).
The team earns a lot a point if it respects the construction plan shown on the wall (<strong>number 7</strong>).</p>
<a class="header" href="print.html#sections--how-does-it-work-" id="sections--how-does-it-work-"><h2>Sections ( How does it work ?)</h2></a>
<p>This paragraph explains the differents conceptions's steps and all the parts needed to build a tower. Here is the general flow diagram :</p>
<p><img src="mechanical/2018/bigRobotSrc/flow_diagram.PNG" alt="alt text" /></p>
<p>The system doesn't need any color detection because all the stars of cubes are always in the same order in the same direction.</p>
<a class="header" href="print.html#the-base" id="the-base"><h3>The base</h3></a>
<p><img src="mechanical/2018/bigRobotSrc/base_render.jpg" alt="alt text" /></p>
<p>This is the firt thing I'm going to talk about but it was the last designed part. Indeed, every part had to be designed to know the constraints and dimensions. Thoses informations where essentials to design the base.</p>
<p>After the design in Fusion 360 in the model environment, the design was imported to the CAM environment still in Fusion.</p>
<p><img src="mechanical/2018/bigRobotSrc/base_cam.PNG" alt="alt text" /></p>
<p>It was then machined with a CNC :</p>
<p><img src="mechanical/2018/bigRobotSrc/base_machining.jpg" alt="alt text" /></p>
<a class="header" href="print.html#the-entry" id="the-entry"><h3>The entry</h3></a>
<p>To swallow the cubes, an entry was designed. It uses simple DC motor with paint roller bought at the <em>Brico</em>.</p>
<p><img src="mechanical/2018/bigRobotSrc/entry.PNG" alt="alt text" /></p>
<p>The entry swallows the first 3 cubes and then select the fourth cube between the 2 last by pushing it with the toothed rack. After that the robot do the same step with the last cube. The rack moves with a rail available on <em>RS component</em> :</p>
<p><strong>IGUS rail</strong>:</p>
<ul>
<li><em>Rail</em> :Igus N Series, NS-01-17-300, Linear Guide Rail 17mm width 300mm length</li>
<li><em>Carriage</em> : Igus Linear Guide Carriage NW-02-17, N</li>
</ul>
<p>To detect when the cube is in the lift, the robot uses a limit switch available on <em>RS Component</em> :</p>
<p><strong>Limit switch</strong> : Snap Action Limit Switch, Roller Lever, Thermoplastic, NC, 125V.</p>
<a class="header" href="print.html#the-lift" id="the-lift"><h3>The lift</h3></a>
<p>The limit switch used in the entry is connected to a pin of an Arduino Uno board so we can detect the state change when a block touches the switch.
That event triggers the lift and thus the block starts to raise up.
Therefore we are using another DC motor with a belt as you can see on the picture below.</p>
<p><img src="mechanical/2018/bigRobotSrc/lift_motor_belt.png" alt="img" /></p>
<p>Thanks to the colour detection we know in which order we have to collect the blocks on the field, so we also know which one comes first in the lift and which floor it has to go to.
It is important to know the specific floor in order to create the pattern showed at the beginning of the game and recognised by the colour and sequence recognition part.</p>
<p>To know when the lift has to stop, we use the encoder of the DC motor so we can precisely know when the motor has to stop.
The encoder is connected to an interruption pin on the Arduino board so the tick counts can be more accurate and have priority.</p>
<p>Once the block is on the right floor, it has to be pushed outside of the lift to already be placed in its position on the tower on a kind of shelf (as you can see in the picture below) which supports the blocks even if there is no other block below.</p>
<p><img src="mechanical/2018/bigRobotSrc/cage.jpg" alt="img" /></p>
<p>Furthermore, to push the block, we use a dynamixel with a gear and a tooth rack to slide a plate along which pushes the block until it reaches the « shelf ».</p>
<p><img src="mechanical/2018/bigRobotSrc/tooth_rack.png" alt="img" /></p>
<p>Then the lift (without any block inside) goes down. To make sure it doesn’t go too much we use another limit switch.
Therefore the lift is immediately stopped, another cube comes in and we can do the cube lifting steps mentioned before over again until all the cubes of the tower are placed.</p>
<p>As mentioned above, we are using DC motors to control our lift.
We have in all 3 motors and they are all connected to a L298 driver (see picture below) controlled by an Arduino Uno board.</p>
<p>Here is a link where you can buy the driver :</p>
<p><a href="https://www.amazon.fr/L298-Motor-Driver/s?ie=UTF8&amp;page=1&amp;rh=i%3Aaps%2Ck%3AL298%20Motor%20Driver">https://www.amazon.fr/L298-Motor-Driver/s?ie=UTF8&amp;page=1&amp;rh=i%3Aaps%2Ck%3AL298%20Motor%20Driver</a></p>
<p><img src="mechanical/2018/bigRobotSrc/driver_L298.png" alt="img" /></p>
<p>We use 2 motors for the rollers to collect the blocks. In order to do so, each one has to turn in the opposite direction of the other but at the same speed.
Thus we connected them to the same driver but inverted the pins of one motor compared to the other one.
These motors don’t have an encoder so their only 2 pins are connected to the driver. We also have the third motor to make the lift go up and down. As we said before, we use the encoder to know where we have to stop so there are pins of the motor connected to the Arduino board. On the other hand the motor is also connected to the driver so we can control its speed, stop it and launch it.</p>
<a class="header" href="print.html#the-cage" id="the-cage"><h3>The cage</h3></a>
<p><img src="mechanical/2018/bigRobotSrc/cage.jpg" alt="alt text" /></p>
<p>The floors can rotate thanks to a dynamixel and a bearing wheel. To place the bearing wheel on the rotating axis we insert the last floor into the others floors with the bearing wheel between them as shown in the next figure :</p>
<p><img src="mechanical/2018/bigRobotSrc/cage_assembly.PNG" alt="alt text" /></p>
<a class="header" href="print.html#external-parts" id="external-parts"><h2>External parts</h2></a>
<p>Most of the part are home made (CNC, 3D printing) but some parts a bought on the market :</p>
<ul>
<li>
<p><strong>IGUS rail</strong></p>
<ul>
<li><em>Small one</em>
<ul>
<li>Rail : Igus N Series, NS-01-17-300, Linear Guide Rail 17mm width 300mm length</li>
<li>Carriage : Igus Linear Guide Carriage NW-02-17, N</li>
</ul>
</li>
<li><em>Big one</em> :
<ul>
<li>Rail : Igus N Series, NS-01-27-300, Linear Guide Rail 27mm width 300mm length</li>
<li>Carriage : Igus Linear Guide Carriage NW-02-27, N</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Lift transmission</strong></p>
<ul>
<li><em>Pitch (distance between teeth)</em> : 2.032 mm</li>
<li><em>Pulley</em> : aluminium, Glass Filled PC Timing Belt Pulley, 6mm Belt Width x 2.032mm Pitch, 36 Tooth, Maximum Bore Dia. 5mm</li>
<li><em>Timing belt</em> : RS Pro, Timing Belt, 315 Tooth, 640.08mm Length X 6mm Width</li>
</ul>
</li>
<li>
<p><strong>Limit switch</strong></p>
<ul>
<li>Snap Action Limit Switch, Roller Lever, Thermoplastic, NC, 125V</li>
</ul>
<a class="header" href="print.html#authors" id="authors"><h1>Authors</h1></a>
<p>Crappe Martin<br />
Hagopian Armen</p>
</li>
</ul>
<a class="header" href="print.html#the-cortex-small-robot" id="the-cortex-small-robot"><h1>The Cortex (small) Robot</h1></a>
<p><img src="mechanical/2018/BallGun_SRC/Cortex.png" alt="alt text" /></p>
<p>This year, the Eurobot task was water purification. As water is not practical around prototype electronics, they used balls to represent water. The balls of the
same colour that is assigned to you during a match will represent clean/purified water whereas balls of the same colour as your opponents represent dirty water
that has to be treated. To ease readability the word &quot;balls&quot; will be used synonymously with &quot;water&quot; for the rest of this article. We are also going to assume that
the team colour assigned to our team is GREEN and therefore green balls = clean water and orange balls (the colour of the opponent team) = dirty water.</p>
<p>At the start of each match the Cortex robot has to collect 8 balls from two different containers on the playing field, sort them and then send them either to the
&quot;home tank&quot; if they are green balls and into the reservoir if they are orange balls. We will take a look the mechanisms we put in place to collect, sort and
send balls during each match for Eurobot 2018.</p>
<a class="header" href="print.html#ball-mechanism" id="ball-mechanism"><h1>Ball Mechanism</h1></a>
<p><img src="mechanical/2018/BallGun_SRC/BallSeparationMech.png" alt="alt text" /></p>
<a class="header" href="print.html#introduction-1" id="introduction-1"><h2>Introduction</h2></a>
<p>Initially, after much thought, we created a system composed of 3 basic parts and a colour detector. There are two parts that are mobile parts and one stagnant outer
case. The system is divided into 4 compartments: the entry point, the colour sensor (CS) compartment, green trap compartment and the orange trap compartment.
The colour detector is embedded in the stagnant outer case. Underneath the outer case is a moving plate controlled by an actuator (the dynamixel AX-12A) and a
rotating &quot;pusher&quot; controlled by a stepper motor to move balls within the outer case.</p>
<p>Essentially there are 4 main steps for a ball to be separated in this system:</p>
<ul>
<li>The ball enters the mechanism at the entry point.</li>
<li>The stepper motor activates and moves the ball to the CS compartment.</li>
<li>The colour sensor detects the colour of the ball. Once  the colour of the ball is known, the dynamixel AX-12A is activated and the opening of the mobile plate
is moved into the corresponding colour position.</li>
<li>The stepper motor activates and moves the ball into the green trap or orange trap.</li>
</ul>
<p>The interest behind this idea is the fact that as the &quot;pusher&quot; is activated and moving another ball can enter at at the entry point and therefore creating a chain
effect which we hoped would gain us time.</p>
<a class="header" href="print.html#the-outer-case-and-colour-sensor" id="the-outer-case-and-colour-sensor"><h2>The outer case and colour sensor</h2></a>
<p><img src="mechanical/2018/BallGun_SRC/OuterCase.png" alt="alt text" /></p>
<p>As you can see here we have the entry point and the colour sensor. How the colour sensor works and its corresponding code can be found in the sensors section.</p>
<a class="header" href="print.html#the-mobile-plate" id="the-mobile-plate"><h2>The mobile plate</h2></a>
<p><img src="mechanical/2018/BallGun_SRC/Purifier.png" alt="alt text" /></p>
<p>Control of the mobile plate was done with a dynamixel AX-12A.</p>
<a class="header" href="print.html#the-pusher" id="the-pusher"><h2>The &quot;pusher&quot;</h2></a>
<p><img src="mechanical/2018/BallGun_SRC/Pusher.png" alt="alt text" /></p>
<p>The pusher as well as the colour detector were eventually excluded from initial prototyping for the Cortex robot because of time constraints and on the basis
of a strategic decision to simplify the mechanism for the qualifying stages. However, the link to an open-source library very useful for controlling stepper motors
is supplied in this document under the actuator section as well.</p>
<a class="header" href="print.html#ball-mechanism-used-in-qualifying-stages" id="ball-mechanism-used-in-qualifying-stages"><h2>Ball mechanism used in qualifying stages</h2></a>
<p><img src="mechanical/2018/BallGun_SRC/Separation.png" alt="alt text" /></p>
<p>This is the system that we used during qualifying stages which only makes use of a mobile plate and rounded edges on the sides and corners
to guide the balls collected. The mobile plate was controlled by dynamixel and the corresponding code and application can be found under the
actuators section of this report.</p>
<a class="header" href="print.html#ball-gun-sending-mechanism" id="ball-gun-sending-mechanism"><h1>Ball Gun (Sending Mechanism)</h1></a>
<p><img src="mechanical/2018/BallGun_SRC/BallGun3D.png" alt="alt text" /></p>
<a class="header" href="print.html#a3d-sketch" id="a3d-sketch"><h2>3D sketch</h2></a>
<p>All the parts of the ball gun is designed on Fusion 360 and printed on a 3D printer except of the balls and the wheel.</p>
<a class="header" href="print.html#why-a-ball-gun" id="why-a-ball-gun"><h2>Why a ball gun?</h2></a>
<p>For the 2018 contest, we had to collect and sort balls by color and then put all the balls collected in the color of the team previously known in a big tank that made reference of a water castle as the balls made reference of water itself. The more balls we threw in the tank, the more points we earned.</p>
<p>We choose to throw the balls with a gun made of a ramp for the direction of the ball and a wheel with a DC motor. as shown on the picture, you can see a fixed ramp, an adjustable ramp and the wheel.</p>
<a class="header" href="print.html#construction-step-by-step" id="construction-step-by-step"><h2>Construction step by step</h2></a>
<p>After lots of discussions with the team, I decided to choose the ball gun to complete the task of throwing balls in the tank. So I first made a prototype of the ball gun made of wood and a small DC motor I found in the lab but for the first tests it appeared that the small DC motor wasn't powerfull enough. So I choose a more powerfull and a better speed motor as a Maxon motor found in the lab and the results were very conclusive.</p>
<p><img src="mechanical/2018/BallGun_SRC/BallGunPrototype.jpg" alt="alt text" /></p>
<p>The next step was to control the speed of the wheel so we could control the distance the ball make after throwing by the ball gun.</p>
<p>I used a small motor driver as the L293D which the specifications were in agreement with the needs of the DC motor.</p>
<p><img src="mechanical/2018/BallGun_SRC/L293DAbsolute.png" alt="alt text" /></p>
<p><img src="mechanical/2018/BallGun_SRC/L293DRecommended.png" alt="alt text" /></p>
<p>You can find the datasheet of the L293D here : https://github.com/Ecam-Eurobot/Tutorials/tree/StevenGaro-patch-1/src/mechanical/2018/BallGun_SRC</p>
<p>To control the H bridge driver, I used a simple arduino uno with a PWM signal so we could test different speeds of the motor.</p>
<p><img src="mechanical/2018/BallGun_SRC/SchemaBlock.png" alt="alt text" /></p>
<p>The precision of the distance the ball make was made experimentaly when we did the different tests.</p>
<p>The code I first used to test the driver with the motor is the next code in arduino :</p>
<pre><code>int inputPin = A0;  // set input pin for the potentiometer
int inputValue = 0; // potentiometer input variable

const int motorPin1  = 5;  // Pin 14 of L293
const int motorPin2  = 6;  // Pin 10 of L293

void setup() {
     // declare the ledPin as an OUTPUT:
     pinMode(motorPin1, OUTPUT);
     
}

void loop() {
     // read the value from the potentiometer:
     inputValue = analogRead(inputPin);

     // send the square wave signal to the LED:
     analogWrite(motorPin1, inputValue);

  digitalWrite(motorPin1, HIGH);
  delayMicroseconds(inputValue); // Approximately 10% duty cycle @ 1KHz
  digitalWrite(motorPin1, LOW);
  delayMicroseconds(1023 - inputValue);
     
}
</code></pre>
<p>When the tests were conclusive enough, we designed a ramp that fit in the robot correctly with an adjustable ramp for the ball to go higher or lower in case we need to modify the distance during the competition.</p>
<p>First we made the fixed ramp that comes from the ball sorting mecanism and end around the wheel.</p>
<p><img src="mechanical/2018/BallGun_SRC/FixedRamp.png" alt="alt text" /></p>
<p>After that we made a straight ramp that shows the ball the direction it must take.</p>
<p><img src="mechanical/2018/BallGun_SRC/StraightRamp.png" alt="alt text" /></p>
<p>And finaly, we designed a small piece that maintain the straight ramp from below and that you can adjust.</p>
<p><img src="mechanical/2018/BallGun_SRC/PieceAdjust.png" alt="alt text" /></p>
<p>After that, all we had to do is to install the gun in the robot and make some tests to determine the best power to give as a PWM to the motor to throw the balls from the distance chosen in the tank and to incorporate the code of the ball gun in the main code of the robot.</p>
<a class="header" href="print.html#electronics" id="electronics"><h1>Electronics</h1></a>
<p>In the next chapters, we will describe all everything related to the electronics of the robots.
Including:</p>
<ul>
<li>Technologies we used</li>
<li>Printed circuit boards we designed</li>
<li>How to use particular sensors</li>
<li>How to use particular actuators</li>
<li>...</li>
</ul>
<a class="header" href="print.html#introduction-2" id="introduction-2"><h1>Introduction</h1></a>
<p>Dynamixels are servomotors with a working angle of 300° dispatched on values 0 to 1023.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/AngleFonctionnement.png" alt="alt text" /></p>
<p>They also have the particularity of beeing able to be used as DC motor. They have a very good motor torque what makes them efficient for a big number of applications. In our robots, we used them for the tasks the robots had to realise during the competition as :</p>
<ul>
<li>Sort balls of different colors</li>
<li>Deploy an arm to push an object on wheels</li>
<li>Deploy a platform on multiple floors to liberate cubic blocks</li>
<li>Maintaining the blocks on every floor or not</li>
<li>Actionate a gear to move blocks</li>
</ul>
<p>The cabling is made with JST 3 pin connectors from a servomotor to another.</p>
<p>Here is a link on amazon to order some : https://www.amazon.fr/ensembles-Micro-connecteur-Fiche-150mm/dp/B01DU9OY40/ref=sr_1_2?ie=UTF8&amp;qid=1525997056&amp;sr=8-2&amp;keywords=jst+connecteur+3+pin&amp;dpID=51oVa4jux4L&amp;preST=<em>SY300_QL70</em>&amp;dpSrc=srch</p>
<p><img src="electronics/actuators/Dynamixels_SRC/PinsConnections.png" alt="alt text" /></p>
<p>The Dynamixels have 2 locations for these connectors because it is possible to connect several servomotors in series and to control them with an addressing. These adresses are represented by unique ID for every dynamixel and it is possible to check with the software Dynamixel Wizard of Roboplus and a USB2Dynamixel.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/USB2Dynamixel.png" alt="alt text" /></p>
<p>Thanks to this software, it is also possible to configurate the dynamixels (registers) like, among others, the baudrate of the servomotor and also to access a serie of informations in real time like the speed, the position, etc.</p>
<a class="header" href="print.html#description" id="description"><h1>Description</h1></a>
<p>Dynamixels are servomotors with a working angle of 300° dispatched on values 0 to 1023.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/AngleFonctionnement.png" alt="alt text" /></p>
<p>They also have the particularity of beeing able to be used as DC motor. They have a very good motor torque what makes them efficient for a big number of applications. In our robots, we used them for the tasks the robots had to realise during the competition as :</p>
<ul>
<li>Sort balls of different colors</li>
<li>Deploy an arm to push an object on wheels</li>
<li>Deploy a platform on multiple floors to liberate cubic blocks</li>
<li>Maintaining the blocks on every floor or not</li>
<li>Actionate a gear to move blocks</li>
</ul>
<p>The cabling is made with JST 3 pin connectors from a servomotor to another.</p>
<p>Here is a link on amazon to order some : https://www.amazon.fr/ensembles-Micro-connecteur-Fiche-150mm/dp/B01DU9OY40/ref=sr_1_2?ie=UTF8&amp;qid=1525997056&amp;sr=8-2&amp;keywords=jst+connecteur+3+pin&amp;dpID=51oVa4jux4L&amp;preST=<em>SY300_QL70</em>&amp;dpSrc=srch</p>
<p><img src="electronics/actuators/Dynamixels_SRC/PinsConnections.png" alt="alt text" /></p>
<p>The Dynamixels have 2 locations for these connectors because it is possible to connect several servomotors in series and to control them with an addressing. These adresses are represented by unique ID for every dynamixel and it is possible to check with the software Dynamixel Wizard of Roboplus and a USB2Dynamixel.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/USB2Dynamixel.png" alt="alt text" /></p>
<p>Thanks to this software, it is also possible to configurate the dynamixels (registers) like, among others, the baudrate of the servomotor and also to access a serie of informations in real time like the speed, the position, etc.</p>
<a class="header" href="print.html#specifications" id="specifications"><h1>Specifications</h1></a>
<ul>
<li>Weight : 53.5g (AX-12/AX-12+), 54.6g (AX-12A)</li>
<li>Dimension : 32mm * 50mm * 40mm</li>
<li>Resolution : 0.29°</li>
<li>Gear Reduction Ratio :  254 : 1</li>
<li>Stall Torque : 1.5N.m (at 12.0V, 1.5A)</li>
<li>No load speed : 59rpm (at 12V)</li>
<li>Running Degree :  0° ~ 300° or Endless Turn</li>
<li>Running Temperature : -5℃ ~ +70℃</li>
<li>Voltage : 9  ~ 12V (Recommended Voltage 11.1V)</li>
<li>Command Signal : Digital Packet</li>
<li>Protocol Type : Half duplex Asynchronous Serial Communication (8bit,1stop,No Parity)</li>
<li>Link (Physical) : TTL Level Multi Drop (daisy chain type Connector)</li>
<li>ID : 254 ID (0~253)</li>
<li>Communication Speed : 7343bps ~ 1 Mbps</li>
<li>Feedback : Position, Temperature, Load, Input Voltage, etc.</li>
<li>Material : Engineering Plastic</li>
</ul>
<a class="header" href="print.html#dynamixel-wizard" id="dynamixel-wizard"><h1>Dynamixel Wizard</h1></a>
<ul>
<li>Download and install the software &quot;Roboplus&quot; on the website www.robotis.com when going in Support&gt;Download&gt;Software&gt;Roboplus</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_Roboplus.png" alt="alt text" /></p>
<ul>
<li>Launch the software and clic on Dynamixel Wizard</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_DynamixelWizard.png" alt="alt text" /></p>
<ul>
<li>Insert the USB2Dynamixel in the USB port of the computer</li>
<li>Connect the 3 pins JST connector in the USB2Dynamixel (TTL side) ansd the dynamixel to verifie or configure</li>
<li>Select « TTL » with the switch on the USB2Dynamixel</li>
<li>Supply the dynamixel separately in its working voltage (9-12V, recommanded 11,1V) with the second port of the dynamixel</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_USB2Dynamixel.png" alt="alt text" /></p>
<ul>
<li>Select the port of your computer where the USB2Dynamixel is connected</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_Port.png" alt="alt text" /></p>
<ul>
<li>Clic on &quot;Open Port&quot;</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_OuvrirLePort.png" alt="alt text" /></p>
<ul>
<li>Make a basic research of the dynamixel to find its ID</li>
</ul>
<ul>
<li>
<p>It is also possible to make advanced research on other baudrates in case of the basic research is not working</p>
</li>
<li>
<p>Once the dynamixel found, selct it on the left side of the window</p>
</li>
<li>
<p>The details of the informations of the dynamixel appears</p>
</li>
<li>
<p>in these details, it is possible to modify the configuration of the dynamixel like its ID, its communication speed (baudrate), its working speed, etc, or also to control it in real time.</p>
</li>
</ul>
<a class="header" href="print.html#examples-of-use" id="examples-of-use"><h1>Examples of use</h1></a>
<p>To use the dynamixels, it is necessary to download first the library &quot;AX_12A_servo_library&quot; that you can find on the github of eurobot here : https://github.com/Ecam-Eurobot/Tutorials/tree/master/src/electronics/actuators/Dynamixels_SRC</p>
<p>You'll have to extract it and place it in Documents/Arduino/libraries.</p>
<p>To configure the dynamixels, we'll use the Arduino software app.</p>
<p>This library possess 4 exemples of use of the dynamixel :</p>
<ul>
<li>Blink : example of control of the red led you can find in the back of every dynamixel</li>
<li>Move : example of control of the dynamixel in servomotor mode by giving it a position</li>
<li>EndlessTurn : example of use in DC motor mode (or wheel mode)</li>
<li>ReadRegister : usefull to dispaly the contents of the registers of the dynamixel</li>
</ul>
<p>These examples are located in Fichier&gt;Exemples&gt;AX-12A on the Arduino app on your computer.</p>
<p>After selecting one of the examples, you have to include the library AX-12A without declaring a specific path because the library is located in the fold &quot;libraries&quot; of the fold &quot;Arduino&quot;.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/Exemples_Include.png" alt="alt text" /></p>
<p>After that you have to configure 3 lines in the code that respond to the needs of the configuration of the connected dynamixel you want to configure :</p>
<pre><code>#define DirectionPin  (10u)
#define BaudRate      (1000000ul)
#define ID            (1u)
</code></pre>
<p>&quot;DirectionPin&quot; is used to indicate the communication direction of the dynamixel. 10u is for writing in the registers so you don't have to change the value.</p>
<p>&quot;BaudRate&quot; defines the communication speed used ( and configurate before with the Dynamixel Wizard)</p>
<p>&quot;ID&quot; represents the ID of the dynamixel that you checked or configured before for the addressing.</p>
<a class="header" href="print.html#application-with-rosserial" id="application-with-rosserial"><h1>Application with ROSserial</h1></a>
<p>As explained in the section &quot;Ball Mechanism&quot;, one dynamixel was used to control the separation of coloured balls (one colour representing
dirty water and the other clean water). This dynamixel has three main positions:</p>
<ul>
<li>Initial_pos_purifier (blocked or closed) position</li>
<li>Clean ball position (opens trap for green balls as in our earlier example)</li>
<li>Dirty ball position (Open trap for orange balls as in our earluer example)</li>
</ul>
<p>Another task that Cortex robot had was to push a bee for the foraging task. This meant we needed a mechanical hand that extended from the robot
in order to push the bee. We used a dynamixel for this action as well. This dynamixel has two main positions:</p>
<ul>
<li>initial_pos_bee (embedded inside robot)</li>
<li>push_pos (extended from robot)</li>
</ul>
<p>We calibrated these positions using the angle diagrams supplied in the data sheet and the good old &quot;trial and error method&quot;.</p>
<a class="header" href="print.html#schematic-block-diagram" id="schematic-block-diagram"><h2>Schematic block Diagram</h2></a>
<p><img src="mechanical/2018/BallGun_SRC/SchemaBloc.png" alt="alt text" /></p>
<p>The communication between the ROS board (Rasberry pi with ROS installed) and the Arduino Uno board that controls the tasks of the Cortex robot takes place over
a USB serial communication better known as ROSserial. The concepts behind ROSserial are explored in detail in the chapter &quot;Software&quot; of this document. I
personally recommend reading that section to better understand the code presented here.</p>
<p>The three main actions of the Arduino board are:</p>
<ul>
<li>Separate dirty balls from clean balls (without colour detection and pusher in qualifying stages)</li>
<li>Push bee</li>
<li>Drive DC motor to shoot clean balls into home tank.</li>
</ul>
<p>These actions are activated and controlled fully by the ROS board. That is, if the ROS board wants to push the bee, the Arduino board must be ready to receive
the message and activate the right actuators in order to push the bee.</p>
<p>! Attention: It is imperative to program the dynamixels to the right baudrate first! This can be done using the USB2Dynamixel and Dynamixel Wizard software as
explained earlier. We had problems controlling the dynamixels via the ROS board at the default baudrate of 1000000 BPS. The communication speed that worked best
was the default baudrate used by ROS on the Raspberry pi, 57600 BPS. After setting the dynamixel in the wizard, all you have to do is change the baudrate
in the code from 1000000ul to 57600ul. (Note: 1000000ul works fine when controlling the dynamixels with only the Arduino board, hmm).</p>
<p>! Attention: These dynamixels use UART to communicate, if you use the Arduino Uno which only has one on board UART module then you will not be able to use
the serial monitor at the same time! DO NOT PUT SERIAL.BEGIN IN SETUP when you want to work with the dynamixels on an Arduino Uno. The best case would be to use a board
with more than one UART module, allowing you to control the dynamixels independent of the serial monitor.</p>
<a class="header" href="print.html#code-1" id="code-1"><h2>Code</h2></a>
<pre><code class="language-cpp">#include &lt;ros.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Int16.h&gt;
#include &lt;AX12A.h&gt;

//Ax-12A IDs and baudrate
#define DirectionPin  (10u)
#define BaudRate     (57600ul)
#define ID1          (7u)  //water purification
#define ID2          (1u)  //bee

//Gun pin definitions
#define i1            5
#define i2            4
#define ena_pwm       9     //PWM pin at 490Hz 

//Water purification definitions
#define clean_ball_position 90
#define dirty_ball_position 916
#define initial_pos_purifier 512
//int initial_pos_purifier = 512;


//water purification declarations
int servo_speed = 500; //speed for ax-12a movement

//Dynamixel AX-12A definitions and global variables
//for control of valve used to separate/purify balls/water.
//@param valve_pos is controlled by ROS board.
int initial_pos_bee = 552;
int valve_pos;

//Start ROS handle.
ros::NodeHandle nh;

void moveBee( const std_msgs::Bool &amp; position_msg){
  
  // Bool variable decides whether to push bee
  // or return to initial position. False = initial position
  // True = push bee position 
  bool pushbee = false;
  int pushbee_pos = 30;   // initial/push position for bee still needs to be calibrated
  
  pushbee = position_msg.data;
  if(pushbee){
    //ax12Move(ID2, pushbee_pos, servo_speed);
    ax12a.moveSpeed(ID2, pushbee_pos, servo_speed);
    }
  else {
    //ax12Move(ID2, initialpos, servo_speed);
    ax12a.moveSpeed(ID2, initial_pos_bee, servo_speed);
    }
}

void moveValve(const std_msgs::Int16 &amp; pos_msg){
  
  valve_pos = pos_msg.data;
  if(valve_pos == 1){
    ax12a.moveSpeed(ID1, clean_ball_position, servo_speed);
    }
  else if (valve_pos == 2){
    ax12a.moveSpeed(ID1, dirty_ball_position, servo_speed);
    }
  else if(valve_pos == 3){
    ax12a.moveSpeed(ID1, initial_pos_purifier, servo_speed);
    }
}

void shootGun( const std_msgs::Int16 &amp; dutycycle_msg){
   //Gun declarations. @param dutycycle (0-255) is controlled
  //by ROS board.
  int dutycycle = 0;
  dutycycle = dutycycle_msg.data;

  //direction
  digitalWrite(i1, LOW);
  digitalWrite(i2, HIGH); 

  //Drive
  analogWrite(ena_pwm, dutycycle);
}

//Move purifier to and fro in order to make
//sure all balls enter compartment
void shake(void);

ros::Subscriber&lt;std_msgs::Bool&gt; bee_ctrl(&quot;bee_control&quot;, &amp;moveBee);
ros::Subscriber&lt;std_msgs::Int16&gt; ballseparator_ctrl(&quot;water_purification&quot;, &amp;moveValve);
ros::Subscriber&lt;std_msgs::Int16&gt; gun_ctrl(&quot;gun_control&quot;, &amp;shootGun);


void setup() {
    
  pinMode(ena_pwm , OUTPUT);
  pinMode(i1, OUTPUT);
  pinMode(i2, OUTPUT);
  
  //Start-up
  ax12a.begin(BaudRate, DirectionPin, &amp;Serial);
  //Remove endless rotation
  ax12a.setEndless(ID1, OFF);
  ax12a.setEndless(ID2, OFF);
  //move into initial position
  ax12a.moveSpeed(ID1, initial_pos_purifier, servo_speed);
  ax12a.moveSpeed(ID2, initial_pos_bee, servo_speed);
  
  nh.initNode();
  
  nh.subscribe(bee_ctrl);
  nh.subscribe(ballseparator_ctrl);
  nh.subscribe(gun_ctrl);
}

//the loop contains is empty.
void loop() {
  nh.spinOnce();
  //delay(50);
  //shake();    
}


void shake(void)
{
    int dir = 0;
    int current_pos = ax12a.readPosition(ID1);
    
    if (valve_pos == 1){
    if (dir == 0){
      if (current_pos != clean_ball_position + 200){
        ax12a.moveSpeed(ID1, clean_ball_position + 200, servo_speed);
      }
      else {
        dir = 1;
      }
      
    }
    else if (dir == 1){
      if (current_pos != clean_ball_position){
        ax12a.moveSpeed(ID1, clean_ball_position - 200, servo_speed);
      }
      else {
        dir = 0;
      }
    }

  }
  if (valve_pos == 2){
    if (dir == 0){
      if (ax12a.readPosition(ID1) != dirty_ball_position + 200){
        ax12a.moveSpeed(ID1, dirty_ball_position - 200, servo_speed);
      }
      else {
        dir = 1;
      }
      
    }
    else if (dir == 1){
      if (ax12a.readPosition(ID1) != dirty_ball_position){
        ax12a.moveSpeed(ID1, dirty_ball_position + 200, servo_speed);
      }
      else {
        dir = 0;
      }
    }

  }
}
</code></pre>
<p>Note: ROS library packages are bulky and can get very big, adding more #includes or libraries to your code will mean more global variables to your overall
project. Make sure that your board, Uno, Nano etc. has enough memory space) for the large amount of global variables. I invite you to compile this
code and load it on an Arduino board. Check the memory details after loading, you will see that we're already almost at the limit !
Think about this for the future.</p>
<a class="header" href="print.html#how-it-works" id="how-it-works"><h2>How it works</h2></a>
<a class="header" href="print.html#libraries" id="libraries"><h3>Libraries</h3></a>
<p>Include all libraries that are necessary for the application but be sure to include ros.h first! Here we will need the AX12A library to control the dynamixel servo motor. We also need certain
source code from the ROSserial std_msgs (allows for communication over ROSserial) package. These source code files that we include will determine the type (int, foat64, String etc..)
of the messages that will be exchanged between the Arduino board and the ROS board.</p>
<p>To control the position of the &quot;bee dynamixel&quot; we only need a true or false signal from ROS but for the &quot;water purifier&quot; we need three positions so we'll rather go for the type int here.
The choice is yours.</p>
<p>Note: We had difficulties working with the std_msgs: Int8 and String when programming with the dynamixels so we settled with Int16 and Bool.</p>
<pre><code class="language-cpp">#include &lt;ros.h&gt;              //ROS packages
#include &lt;std_msgs/Bool.h&gt;     //ROS std messages needed for com
#include &lt;std_msgs/Int16.h&gt;
#include &lt;AX12A.h&gt;            //Dynamixel control
</code></pre>
<a class="header" href="print.html#declarations-and-pin-definitions" id="declarations-and-pin-definitions"><h3>Declarations and pin definitions</h3></a>
<p>Declare as many variables as possible through the #define method in order to save global variable space on the Arduino Uno, for example:</p>
<pre><code class="language-cpp">//Gun pin definitions
#define i1            5
#define i2            4
#define ena_pwm       9     //PWM pin at 490Hz 

//water purification declarations
int servo_speed = 500;      //speed for ax-12a movement
</code></pre>
<p>Don't forget to create the ROS node!</p>
<pre><code class="language-cpp">//Start ROS handle.
ros::NodeHandle nh;    //Create a ROS node
</code></pre>
<a class="header" href="print.html#create-callback-function" id="create-callback-function"><h3>Create callback function</h3></a>
<p>The Arduino board is seen as a node by the ROS board. In order to receive commands from it we need to subscribe to a topic to see what the ROS board has sent us.
This is how we create a topic and a callback function:</p>
<pre><code class="language-cpp">//For ROS, the name of the topic is gun_control and the ROS board can send 
//messages only of type Int16. The name of the function in Arduino that needs 
//to be called every time we receive a message is shootGun
ros::Subscriber&lt;std_msgs::Int16&gt; gun_ctrl(&quot;gun_control, &amp;shootGun);   
</code></pre>
<p>Now we need to implement the call back function, for example the callback function for the water_purification topic:</p>
<pre><code class="language-cpp">void moveValve(const std_msgs::Int16 &amp; pos_msg){
  
  valve_pos = pos_msg.data;   //Get data sent from ROS
  if(valve_pos == 1){
    ax12a.moveSpeed(ID1, clean_ball_position, servo_speed); //cross-reference library for more info
    }
  else if (valve_pos == 2){
    ax12a.moveSpeed(ID1, dirty_ball_position, servo_speed);
    }
  else if(valve_pos == 3){
    ax12a.moveSpeed(ID1, initial_pos_purifier, servo_speed);
    }
}
</code></pre>
<a class="header" href="print.html#set-up" id="set-up"><h3>Set-up</h3></a>
<p>We need to setup the dynamixel, subscribe to the our topics and we need to initialise the ROS node we created.</p>
<pre><code class="language-cpp">  //Start-up
  ax12a.begin(BaudRate, DirectionPin, &amp;Serial);
  //Remove endless rotation
  ax12a.setEndless(ID1, OFF);
  ax12a.setEndless(ID2, OFF);
  //move into initial position
  ax12a.moveSpeed(ID1, initial_pos_purifier, servo_speed);
  ax12a.moveSpeed(ID2, initial_pos_bee, servo_speed);
  
  nh.initNode();
  
  nh.subscribe(bee_ctrl);
  nh.subscribe(ballseparator_ctrl);
  nh.subscribe(gun_ctrl);
</code></pre>
<a class="header" href="print.html#loop" id="loop"><h3>loop</h3></a>
<p>Keep it simple. Do not over load the loop. We want to nh.spinOnce to to be called as often as possible without interruption.</p>
<pre><code class="language-cpp">nh.spinOnce();    //Checks topics that we subscribed to and calls callback function if ROS board has published something correctly. 
</code></pre>
<a class="header" href="print.html#what-ros-needs-to-send" id="what-ros-needs-to-send"><h3>What ROS needs to send</h3></a>
<p>To properly implement this code, you will need a ROS board and an Arduino board. The default baudrate is 57600 with ROS. ROS needs to publish:</p>
<ul>
<li>true or false to the topic &quot;bee_ctrl&quot; to position dynamixel</li>
<li>1, 2 or 3 to the topic &quot;ballseparator_ctrl&quot; to position dynamixel</li>
<li>0-255 to set the duty cycle of the PWM signal at pin 9 of the Arduino.</li>
</ul>
<a class="header" href="print.html#references" id="references"><h1>References</h1></a>
<ul>
<li>
<p>e-manual : http://support.robotis.com/en/</p>
</li>
<li>
<p>youtube vidéo for all the steps of the use of the Dynamixel Wizard : https://www.youtube.com/watch?v=YJ9b68hx5Qc&amp;version=3&amp;hl=ko_KR</p>
</li>
<li>
<p>website of the manufacturer : http://en.robotis.com</p>
</li>
<li>
<p>AX-12A library : https://github.com/ThingType/AX-12A-servo-library</p>
</li>
</ul>
<a class="header" href="print.html#sonar" id="sonar"><h1>Sonar</h1></a>
<p>A sonar is a sensor allowing you to measure the distance to an obstacle thanks to high frequency waves. To keep correct measured values it is better to use the sensor we chose between 2cm and 400cm. The model of our sonar is HC-SR04. There are 4 pins on this sensor : TRIG, ECHO, VCC and GND (as you can see on the picture below).</p>
<p><img src="img/electronics/sonar/HCSR04.png" alt="img" /></p>
<p>It contains a transmitter and a receiver.
The distance measure is pretty simple. Firstly, you have to send a signal on the TRIG pin so the sonar emits a wave of 8 pulses at 40kHz. Then the ECHO pin is set to the «HIGH» level until the emitted signal goes to the obstacle and comes back to the sensor (as you can see on the following picture).</p>
<p><img src="img/electronics/sonar/ultrasonic_waves.png" alt="img" /></p>
<p>Of course, you have to connect the sensor to a microcontroller. You can connect the VCC to the 5V pin of your board, the GND to the ground pin and the TRIG and ECHO to digital pins of your controller as illustrated on the picture below.</p>
<p><img src="img/electronics/sonar/sonar_pins.png" alt="img" /></p>
<p>Finally it is also important to know that the measuring angle with the HC-SR04 sonar is 30 degrees.  Which is short, so the sonar can only see in front of him</p>
<p>All these information are also explained in the following websites :</p>
<p><a href="https://www.gotronic.fr/pj2-hc-sr04-utilisation-avec-picaxe-1343.pdf">https://www.gotronic.fr/pj2-hc-sr04-utilisation-avec-picaxe-1343.pdf</a></p>
<p><a href="https://wiki.mchobby.be/index.php?title=HC-SR04">https://wiki.mchobby.be/index.php?title=HC-SR04</a></p>
<p><a href="http://web.eece.maine.edu/%7Ezhu/book/lab/HC-SR04%20User%20Manual.pdf">http://web.eece.maine.edu/~zhu/book/lab/HC-SR04%20User%20Manual.pdf</a></p>
<p>Here is an online store where you can buy this sensor :</p>
<p><a href="https://shop.mchobby.be/proximite/561-senseur-ultrason-hc-sr04-3232100005617.html">https://shop.mchobby.be/proximite/561-senseur-ultrason-hc-sr04-3232100005617.html</a></p>
<p>Images references :</p>
<p><a href="http://geii.iut-troyes.univ-reims.fr/wikigeii/index.php?title=Fichier:Working-of-HC-SR04-Ultrasonic-Sensor.jpg">http://geii.iut-troyes.univ-reims.fr/wikigeii/index.php?title=Fichier:Working-of-HC-SR04-Ultrasonic-Sensor.jpg</a></p>
<p><a href="http://www.instructables.com/id/HC-SR04-Ultrasonic-Sensor-With-Raspberry-Pi-2/">http://www.instructables.com/id/HC-SR04-Ultrasonic-Sensor-With-Raspberry-Pi-2/</a></p>
<p><a href="https://randomnerdtutorials.com/complete-guide-for-ultrasonic-sensor-hc-sr04/">https://randomnerdtutorials.com/complete-guide-for-ultrasonic-sensor-hc-sr04/</a></p>
<a class="header" href="print.html#tutorial" id="tutorial"><h1>Tutorial</h1></a>
<a class="header" href="print.html#simple-arduino-code" id="simple-arduino-code"><h2>Simple Arduino code</h2></a>
<p>To be able to test the simple code showed in this part you have to connect the sonar sensor to your Arduino Uno board as showed on the third picture hereinabove. You also have to connect the TRIGG pin of the sonar to the pin 12 on your Arduino board and the ECHO pin of the sonar to the pin 13 on the Arduino board. Of course you can change these values on the following code if needed.<br />
You are now ready to upload the code :</p>
<pre><code class="language-cpp">
#define TRIGG 12 // Broche TRIGGER
#define ECHO 13    // Broche ECHO
                                               // definition du Timeout
const long TIMEOUT = 25000UL; // 25ms = ~8m à 340m/s

float son= 340.0 / 1000; //vitesse du son dans l'air (mm/µs)

void setup() {

  pinMode(TRIGG, OUTPUT);  //Configuration des broches
  digitalWrite(TRIGG, LOW); // La broche TRIGGER doit être à LOW au repos
  pinMode(ECHO, INPUT);

  Serial.begin(9600); //Démarrage de la liaison série
}

void loop() {

  digitalWrite(TRIGG, HIGH); // Lance une mesure de distance en envoyant
  delayMicroseconds(10);  //une impulsion HIGH de 10µs sur la broche TRIGGER
  digitalWrite(TRIGG, LOW);

  int mesure = pulseIn(ECHO, HIGH, TIMEOUT); // Mesure le temps entre
                                          // l'envoi de l'ultrason et sa réception

  float distance_mm = mesure / 2.0 * son; //calcul de la distance grâce au temps
                                      //on divise par 2 car le son fait un aller-retour

  Serial.print(&quot;Distance: &quot;); //Affichage des résultats
  Serial.print(distance_mm);
  Serial.println(&quot;mm&quot;);

  delay(500); //temps entre chaque mesure (ms)
}

</code></pre>
<p>To verifiy if everything is working correctly after uploading the code you can click on the Serial monitor icon on the Arduino IDE (as shown on the picture below) to see what distance the sonar returns in milimeters.</p>
<p><img src="img/electronics/sonar/serial_monitor.png" alt="img" /></p>
<p>Link to the code on Ecam Eurobot Github :</p>
<p><a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/ultrasound/arduino/sonar_simple_test_no_ROS.ino">https://github.com/Ecam-Eurobot/Eurobot-2018/blob/ultrasound/arduino/sonar_simple_test_no_ROS.ino</a></p>
<p>Go check in ROS and Arduino chapter for combining Sensor, Arduino and ROS</p>
<a class="header" href="print.html#reflexion" id="reflexion"><h1>Reflexion</h1></a>
<p>This kind of sensor need that the signal leaves the <em>Trigger</em> head and go back to the <em>Echo</em> head.</p>
<p>If the signal leaves the <em>Trigger</em> head and doesn't come back to the <em>Echo</em> head then the sensor decide that there is nothing.</p>
<p>So when there is an obstacle in front of the sensor this obstacle must be in front of the 2 head of the sensor else for the sensor there is no obstacle.</p>
<p>Before putting the sensor on the robot think about this, is it best to put the sensor horizontally or vertically?</p>
<a class="header" href="print.html#the-colour-sensor" id="the-colour-sensor"><h1>The colour Sensor</h1></a>
<p>There are a wide range of colour sensors currently available today. After studying various sensors that are currently on the market we
decided to use the RGB Colour Sensor with IR filter and White LED from Adafruit mostly because of its size, cross-platform support (including python code https://learn.adafruit.com/adafruit-color-sensors/circuitpython-code)
and the fact that it communicates with I2C, the communication bus we had planned on using initially. Eventually we bought the even smaller version, the Flora Colour Sensor with White Illumination LED,
both of them use the same integrated circuit, the Adafruit TCS34725.</p>
<p>On board circuitry includes:</p>
<ul>
<li>3.3V regulator so you can power the breakout with 3-5VDC safely and level shifting for the I2C pins so they can be used with 3.3V or 5V logic</li>
<li>neutral 4150°K temperature LED with a MOSFET driver on board to illuminate what you're trying to sense.</li>
<li>An IR blocking filter, localized to the color sensing photodiodes, minimizes the IR spectral component of the incoming light and allows colour measurements to be made more
accurately</li>
</ul>
<p><img src="electronics/sensors/ColorSensor/Flora.jpg" alt="alt text" /></p>
<p>More information on this colour sensor can be found here</p>
<a class="header" href="print.html#assembly-1" id="assembly-1"><h2>Assembly</h2></a>
<a class="header" href="print.html#on-the-flora" id="on-the-flora"><h3>On the Flora:</h3></a>
<pre><code>3.3v -&gt; 3v (red wire)
GND -&gt; GND (black wire)
SDA -&gt; SDA (white wire) 
SCL -&gt; SCL (green wire)
</code></pre>
<a class="header" href="print.html#on-the-arduino" id="on-the-arduino"><h3>On the Arduino:</h3></a>
<pre><code>Connect SCL    to analog 5
Connect SDA    to analog 4
Connect VDD    to 3.3V DC
Connect GROUND to common ground
</code></pre>
<a class="header" href="print.html#the-library" id="the-library"><h2>The library</h2></a>
<p>To start working with this sensor it is advised to start by downloading the Arduino library from the github link provided in the references and install
it into the library folder of your Arduino IDE. Hint: the right Arduino folder is usually found in My Documents. The library is an object-orientated library
that allows to create a colour sensor object and access all  its capabilities through its methods.</p>
<a class="header" href="print.html#the-code" id="the-code"><h2>The Code</h2></a>
<p>After installing the library, the best thing to do is start with the examples already provided by the library. I started with and tweaked the mostly the
Colorview code because it allows to give us values between 0 and 255 for the different RGB colours (not 100% accurate but accurate enough) of the
object being detected. here's an example:</p>
<pre><code class="language-cpp">#include &lt;Wire.h&gt;                  //include Wire.h to be able to communicate through I2C on Arduino board
#include &quot;Adafruit_TCS34725.h&quot;     //Colour sensor library

//Create colour sensor object declaration, to see effects of different integration time and gain
//settings, check the datatsheet of the Adafruit TCS34725.  
Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);

void setup() {
  Serial.begin(9600);
  Serial.println(&quot;Color View Test!&quot;);

  //Start-up colour sensor
  if (tcs.begin()) {
    Serial.println(&quot;Found sensor&quot;);
  } else {
    Serial.println(&quot;No TCS34725 found ... check your connections&quot;);
    while (1); // halt!
  }
}


void loop() {

  uint16_t clear, red, green, blue;
  uint16_t upperrangeG[3] = {100, 153, 71};
  uint16_t lowerrangeG[3] = {50, 104, 52};
  uint16_t upperrangeO[3] = {216,75,44};
  uint16_t lowerrangeO[3] = {155, 60, 32};  

  //Collect raw data from integrated circuit using interrupts
  tcs.setInterrupt(false);      // turn on LED

  delay(60);  // takes 50ms to read 
  
  tcs.getRawData(&amp;red, &amp;green, &amp;blue, &amp;clear);
  tcs.setInterrupt(true);  // turn off LED

  // Figure out some basic hex code for visualization
  uint32_t sum = clear;
  float r, g, b;
  r = red; 
  r /= sum;
  g = green; 
  g /= sum;
  b = blue; 
  b /= sum;
  r *= 256; g *= 256; b *= 256;
  Serial.print(&quot;\t&quot;);
  
  Serial.print((int)r, HEX); Serial.print((int)g, HEX); Serial.print((int)b, HEX);
  Serial.println();

  Serial.print((int)r ); Serial.print(&quot; &quot;); Serial.print((int)g);Serial.print(&quot; &quot;);  Serial.println((int)b );

  if((r &lt; upperrangeG[0] &amp;&amp; g &lt; upperrangeG[1] &amp;&amp; b &lt; upperrangeG[2]) || (r &gt; lowerrangeG[0] &amp;&amp; g &gt; lowerrangeG[1] &amp;&amp; b &gt; lowerrangeG[2])){
    delay(50);
    Serial.print(&quot;Green&quot;);
  }
  if((r &lt; upperrangeO[0] &amp;&amp; g &lt; upperrangeO[1] &amp;&amp; b &lt; upperrangeO[2]) || (r &gt; lowerrangeO[0] &amp;&amp; g &gt; lowerrangeO[1] &amp;&amp; b &gt; lowerrangeO[2])){
    delay(50);
    Serial.print(&quot;Orange&quot;);
  }
}
</code></pre>
<a class="header" href="print.html#how-it-works-1" id="how-it-works-1"><h2>How it works</h2></a>
<p>After creating and setting up the colour sensor, we need to first set the upper and lower RGB ranges of the goal colour we want to detect. As we know,
we don't have the best accuracy with colours sensors but we can try to isolate the colours we want through trial and error and make sure other colours
are not detected instead of our goal colour. Here is the definition of the ranges for orange and green detection:</p>
<pre><code class="language-cpp">  uint16_t clear, red, green, blue;
  uint16_t upperrangeG[3] = {100, 153, 71};
  uint16_t lowerrangeG[3] = {50, 104, 52};
  uint16_t upperrangeO[3] = {216,75,44};
  uint16_t lowerrangeO[3] = {155, 60, 32};  
</code></pre>
<p>Then we need to calculate the RGB colours between 0 and 255:</p>
<pre><code class="language-cpp">  // Figure out some basic hex code for visualization
  uint32_t sum = clear;
  float r, g, b;
  r = red; 
  r /= sum;
  g = green; 
  g /= sum;
  b = blue; 
  b /= sum;
  r *= 256; g *= 256; b *= 256;
</code></pre>
<p>This program prints the RGB values of all colours detected by the sensor but will print &quot;Green&quot; or &quot;Orange&quot; if the colour detected is found within
the specified range limits.</p>
<pre><code class="language-cpp"> if((r &lt; upperrangeG[0] &amp;&amp; g &lt; upperrangeG[1] &amp;&amp; b &lt; upperrangeG[2]) || (r &gt; lowerrangeG[0] &amp;&amp; g &gt; lowerrangeG[1] &amp;&amp; b &gt; lowerrangeG[2])){
    delay(50);
    Serial.print(&quot;Green&quot;);
  }
</code></pre>
<a class="header" href="print.html#references-1" id="references-1"><h1>References</h1></a>
<ul>
<li>Commercial page: https://www.adafruit.com/product/1356</li>
<li>Online tutorial: https://learn.adafruit.com/adafruit-all-about-arduino-libraries-install-use</li>
<li>Library: https://github.com/adafruit/Adafruit_TCS34725</li>
<li>Datasheet: https://cdn-shop.adafruit.com/datasheets/TCS34725.pdf</li>
</ul>
<a class="header" href="print.html#the-mouse" id="the-mouse"><h1>The Mouse</h1></a>
<p>This is a pc mouse.
It gives a travel distance in x-axis and y-axis. It can't see rotation.</p>
<a class="header" href="print.html#application" id="application"><h1>Application</h1></a>
<p>If the mouse is connect in a Linux os, we can read the values in <code>dev/input/mice</code>.</p>
<pre><code class="language-python">import struct

with open(&quot;/dev/input/mice&quot;,&quot;rb&quot;) as fd:
    while True:
        # unpack data to have x and y
        y,x = struct.unpack(&quot;xbb&quot;,fd.read(3))

</code></pre>
<p>The distance given is not a distance in cm, we need to use a multiplication parameter
to have the distance in cm.</p>
<p>We test the it on the 2019 eurobot.
You can find the files with ROS in the little_robot branch of Eurobot-2019, <code>little_robot/ROS_packages/R&amp;D/mouse/src</code>.</p>
<a class="header" href="print.html#pros-1" id="pros-1"><h2>Pros</h2></a>
<ul>
<li>Distance traveled compute on the field.</li>
</ul>
<a class="header" href="print.html#cons-1" id="cons-1"><h2>Cons</h2></a>
<ul>
<li>The raspberry must be fast enough.</li>
<li>It's not better than the encoder of the mechanum wheels.</li>
<li>It didn't see the rotations.</li>
</ul>
<a class="header" href="print.html#printed-circuit-boards" id="printed-circuit-boards"><h1>Printed Circuit Boards</h1></a>
<blockquote>
<p><em>last updated on May 11, 2018</em></p>
</blockquote>
<p>Three types of printed circuit boards were developed for our two robots. The following section presents these boards, it utilities and it conception
and gives you all the necessary elements to understand, recreate and use it.</p>
<a class="header" href="print.html#starting-board" id="starting-board"><h2>Starting Board</h2></a>
<blockquote>
<p><em>last updated on May 11, 2018</em></p>
</blockquote>
<p>Inspired by past version of the starting board</p>
<p>The utility of this PCB is to gather the component serving to the start sequence. Normally this is the only interface with the robot during the
competition.</p>
<p>First, we used three switches for configuring three main points of our robot :</p>
<ul>
<li>
<p>Team configuration
We have to setup the starting side for the next match to the robot. It behaviour is different if the robot play as the green or the orange team.
Consequently, this switch set this point before the match start.</p>
</li>
<li>
<p>Strategy Configuration
It makes possible to choose between two kinds of implemented strategies before the match. For example, just before the start, we have the
possibility of aggressive or defensive strategy, function of the opponent.</p>
</li>
<li>
<p>Initialisation Switch</p>
</li>
</ul>
<p>This switch launches an initialisation sequence. After the power up of the robot and before its first move, we wanted to have the possibility to check
all different robot's systems. This switch indicates with a DEL if all systems are operational. This is a kind of automatic check list before the match
and the first move of the robot.</p>
<p>All these switches are linked to two DEL. First one to electrically confirm switches' position and the associated setting and the second one used to
have the response of the robot operating system. With these two LEDs, we are sure that our robot understood all these parameters.</p>
<a class="header" href="print.html#useful-information" id="useful-information"><h3>Useful information</h3></a>
<ul>
<li>Correspondence</li>
</ul>
<p>Strategy</p>
<p>Pin 1 - UP   = GREEN = 0 (out raspberry) - DOWN  = RED = 1 (out raspberry)</p>
<p>Initialisation</p>
<p>Pin 2 - UP   = GREEN = 0 (out raspberry) - DOWN  = RED = 1 (out raspberry)</p>
<p>Team</p>
<p>Pin 3 - LEFT = GREEN = 1 (out raspberry) - RIGHT = RED = 1 (out raspberry)</p>
<p>Start</p>
<p>Pin 4 - piece IN     = 0 (out raspberry) - piece OUT   = 1 (out raspberry)</p>
<ul>
<li>Switch placement</li>
</ul>
<p>The emplacement is taken when the splayed side is on the right then :</p>
<ol>
<li>Strategy switch is in the upper left corner</li>
<li>Initialisation switch is on the right side of the strategy switch</li>
<li>Team switch is in the lower left corner</li>
</ol>
<p>Finally, the starter switch is plugged on the board. It consists of a relay, sending a binary information to the ROS operating system. Linked to a 0.5m cable, this system allows to launch the match sequence pulling on it.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h3>Getting Started</h3></a>
<p>The following code is launched with ROS (if you haven't read yet this section, it might be tricky) this is a simplified version of the code used in
2018 robots. The aim of this code is the setting of a parameter in a configuration file in the first place, next the code publish on the start topic
when the start switch is pulled. This last action indicates to all script listening this topic the beginning of a game.</p>
<pre><code class="language-python">import sys
import random
import rospy
from std_msgs.msg import Empty

raspberry = &quot;-r&quot; in sys.argv

pi = None
# If passed the -r argument, load the rapsberry libs
if raspberry:
    import pigpio
    pi = pigpio.pi()

rospy.init_node('startup_conf')

# Robot
robot = rospy.get_param(&quot;/robot&quot;)

pub_start = rospy.Publisher('start', Empty, queue_size=1)
pub_reset = rospy.Publisher('reset', Empty, queue_size=1)


# GPIO PIN CONFIGURATIONS
# This pin will be used to configure the team
pin_team = 23

# This pin will be used to drive a led to indicate that the team has been set correctly in ROS
pin_team_feedback = 21

# This pin will be used to drive a led to indicate that the start is understood by ROS
pin_strategy_feedback = 20

# This pin will be used to launch robot
pin_start = 12

# Function to set team parameter in the configuration file 
def update_team(gpio, level, tick):
    if raspberry:
        if level:
            rospy.set_param(&quot;/team&quot;, &quot;red&quot;)
            rospy.set_param(&quot;/reset/position&quot;, rospy.get_param(&quot;/start/{}/red/position&quot;.format(robot)))
            pi.write(pin_team_feedback, 1)
        else :
            rospy.set_param(&quot;/team&quot;, &quot;green&quot;)
            rospy.set_param(&quot;/reset/position&quot;, rospy.get_param(&quot;/start/{}/green/position&quot;.format(robot)))
            
   # Blink 2 times for acknowledge
            pi.write(pin_team_feedback, 0)
    else:
        choice = random.choice([&quot;green&quot;, &quot;red&quot;])
        team = rospy.set_param(&quot;/team&quot;, choice)
        rospy.logwarn(&quot;Setting team automatically to: &quot; + choice)
        if team == &quot;green&quot;:
            rospy.set_param(&quot;/reset/position&quot;, rospy.get_param(&quot;/start/{}/green/position&quot;.format(robot)))
        elif team == &quot;red&quot;:
            rospy.set_param(&quot;/reset/position&quot;, rospy.get_param(&quot;/start/{}/red/position&quot;.format(robot)))

    reset()


publish = True

# If high level on start pin this function publish on the start topic
def start(gpio, level, tick):
    global publish
    rospy.sleep(0.2)
    if raspberry and not pi.read(pin_start):
        if publish :
            pi.write(pin_strategy_feedback, 1)
            pub_start.publish(Empty())
            publish = False

# Function to reset all set parameters
def reset():
    pub_reset.publish(Empty())
    if raspberry:
        if pi.read(pin_start):
            global publish
            publish = True
            pi.write(pin_strategy_feedback, 0)

com = False
init = True

if raspberry and init:
    pi.set_mode(pin_team, pigpio.INPUT)
    pi.set_mode(pin_start, pigpio.INPUT)
    pi.set_mode(pin_team_feedback, pigpio.OUTPUT)
    pi.set_mode(pin_strategy_feedback, pigpio.OUTPUT)
    pi.set_pull_up_down(pin_start, pigpio.PUD_DOWN)
    pi.set_pull_up_down(pin_strategy_feedback, pigpio.PUD_DOWN)
    teamInterrupt = pi.callback(pin_team, pigpio.EITHER_EDGE, update_team)
    startInterrupt = pi.callback(pin_start, pigpio.EITHER_EDGE, start)

    update_team(None, pi.read(pin_team), None)
else:
    rospy.sleep(1)
    update_team(None, None, None)

while not rospy.is_shutdown():
    pass
</code></pre>
<p>Below, you have the circuit to implement  between the board and the raspberry running ROS</p>
<p><img src="electronics/pcb/pictures/Start_F.jpg" alt="Start PCB Front" /></p>
<ul>
<li>The two couples of black and red wires are the 5V</li>
<li>The white wire is connected to the pin 12 on the raspberry and send startup interrupt information</li>
<li>The red point is the pin normally connected to the 23rd pin on the raspberry and send team switch information</li>
<li>The brown and green wires are connected to the pins 21 and 20 on the raspberry and connect acknowledge pins</li>
</ul>
<p>If you copied the code and connect all cable as the pictures shows, the pulling of the start cable induce a publication on the start ROS topic (visible
with an echo on this topic) and the modification of the switch place sets the team parameter ROS file.</p>
<p>The switch strategy and initialisation were planned to respectively set a different implemented strategy and launch a initialisation (tests)
sequence. It was not used in 2018 due to a lack of time but they are already on the PCB for a future robot.</p>
<p>Finally, in the real implementation on ROS, the pin configuration is placed in a .yaml file gathering all information required about raspberry pinout.
Then, the code used to get pin number is</p>
<pre><code class="language-python">rospy.get_param(&quot;/path/name&quot;)
</code></pre>
<p><a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/differential_driver/ros_packages/strategy/src/startup_conf.py">Github link for code</a></p>
<p>--- <a href="https://">OneDrive link for Altium project</a></p>
<blockquote>
<p><em>last updated on May 11, 2018</em></p>
</blockquote>
<a class="header" href="print.html#motor-board" id="motor-board"><h2>Motor Board</h2></a>
<p>The goal of this board is to bring individual intelligence for every motor used on our robots. It allows to associate a microcontroller (ATmega328) with each motor. This main component is used for two aspects : regulation and communication.</p>
<a class="header" href="print.html#regulation" id="regulation"><h3>Regulation</h3></a>
<p>For the smaller robot, the operating system send speed consign to the four motors. Consequently, the goal for the motor is reaching this speed in a minimum of time and after conserving this value. The regulator implemented in the microcontrollers is Proportional Integral Derivative regulators. It's parameters allow to influence the way to consign reaching for the motor. Thanks to it, each motor, individually can follow the ROS order with a maximum of precision.</p>
<p>PID's parameters were found with experimentation and all sources used for implementation are in the code file.</p>
<a class="header" href="print.html#communication" id="communication"><h3>Communication</h3></a>
<p>As said in the previous part, this is the operating system ROS the main brain of the robot. Consequently, this brain has to communicate with its slave.
The communication protocol used on our robots is SPI. It induces that a bus has to be built between all motor and ROS. Effectively, a broker gathers
the signal for the motor but in any case each motor has to be linked to the bus. A role of the board is this connection via a SPI connector.</p>
<a class="header" href="print.html#getting-started-1" id="getting-started-1"><h3>Getting Started</h3></a>
<p>To simplify the tutorial, we will use an arduino UNO instead of ATmega328 microcontroller. For the robot, the reason why we use a ATmega328 alone is the size of the system. The microcontroller and its oscillator are sufficient for our application and take less place on the robot. However, in this tutorial, we will use the arduino UNO to slightly simplify manipulation.</p>
<p>Regarding the regulation, the following code implements the PID regulator. Its parameters were found after experimentation. It depends on the motor and the load. We simply adjusted the parameters until the motor behaviour was the expected one. (mr. Marchand knows the methodology ;) )</p>
<p>The blocks of the system are described below :</p>
<ul>
<li>Encoder</li>
</ul>
<p>The encoder sends the rotation information to the controller. In our code, we used the <em>Encoder.h</em> library to handle it. At this moment, we have the velocity of the wheel in rad/s.</p>
<ul>
<li>Motor control</li>
</ul>
<p>The H bridge is used for power two motors at the same. One the left side of the board there are all control pins (PWM and DIR for the two motors) and power supply of command (5V). On the other side of the board, you have the motor output and the motor power supply (24V).</p>
<pre><code class="language-cpp">#includes &lt;Wire.h&gt;
#includes &lt;PID_v1.h&gt;
#includes &lt;ecamlib.h&gt;

#include &lt;Encoder.h&gt;
#include &lt;FlexiTimer2.h&gt;

// Defines the pins to control the motor driver
// pin 5 controls the voltage to the motor by a PWM
// pin 4 controls the direction of the motor
const int PWM = 5;
const int DIR = 4;

// Define pin and tick per revolution of the encoder
Encoder motor_encoder = Encoder(2, 3);
const int ENCODER_TICKS_PER_REV = 3200;

// Defines the time between two samples in milliseconds for speed capture
const int CADENCE_MS = 50;
volatile double dt = CADENCE_MS / 1000.;

// Motor control variables and PID configuration
float motor_speed = 6.28319;
float gain_p = 15.0;
float gain_i = 5.0;
float gain_d = 0.5;

// Define angular velocity
volatile double omega;

// PID declaration function of used library
double Setpoint, Input, Output;
PID myPID(&amp;Input, &amp;Output, &amp;Setpoint,gain_p,gain_i,gain_d, DIRECT);

// Variable to keep track of the old encoder value
volatile long old_encoder = 0;

void setup() {
    // set timer 0 divisor to 1 for PWM frequency of 62500.00 Hz
    TCCR0B = TCCR0B &amp; B11111000 | B00000001;

    pinMode(PWM,OUTPUT); 
    pinMode(DIR,OUTPUT);
 
 // Periodic execution of isrt() function thanks to FlexiTimer2 library    
    FlexiTimer2::set(CADENCE_MS, 1/1000., isrt); 
    FlexiTimer2::start();

    myPID.SetMode(AUTOMATIC);
    myPID.SetSampleTime(CADENCE_MS);

    // Motor direction 
    digitalWrite(DIR,LOW);
        
}

void loop() {
 
 Setpoint = (double) (abs(motor_speed));
    if (motor_speed &gt; 0) {
        digitalWrite(DIR, LOW);
    } else {
        digitalWrite(DIR, HIGH);
    }
    
    Input = abs(omega);
    
    myPID.Compute();
    
    analogWrite(PWM, Output);
    
    Serial.print(&quot;Omega : &quot;);
    Serial.println(omega);
    delay(CADENCE_MS);
}

// Speed measurement 
void isrt(){
    int deltaEncoder = motor_encoder.read() - old_encoder;
    old_encoder = motor_encoder.read();
    
    // Angular velocity 
    omega = ( (2.0 * 3.141592 * (double)deltaEncoder) / ENCODER_TICKS_PER_REV ) / dt;  // rad/s
}
</code></pre>
<p>Remark : All used library is on Github (see link at the end)</p>
<ul>
<li>Controller</li>
</ul>
<p>Motor are controlled by the arduino with PWM signals. The implemented PID regulator computes the necessary duty cycle to send for reaching the target velocity function of its parameters.</p>
<p>The following complete circuit is shown below</p>
<p>--- PIC OF THE CIRCUIT --- UNO + H Bridge + MOTOR - DRAW CONNECTION --- After robot's deconstruction</p>
<p>The implemented PID regulator computes to reach the target velocity. So at this moment, you have an arduino UNO controlling motor in velocity thanks to a PID regulation. All regulation is visible in the Serial Window of the Arduino software.</p>
<p>Now the next step is to give the control of the motor velocity to ROS core on the raspberry. For that, we implemented a SPI connection with ROS. These concepts are explained in the ROS serial section. On the motor side, a function is added on the main code on the arduino UNO to receive data from master and set value of PID (proportional gain, integrative gain, derivative gain and velocity setpoints.</p>
<pre><code class="language-cpp">// function that executes whenever data is received from the master
// this function is registered as an event, see setup()
void receiveEvent(int howMany) {
    if (Wire.available() &gt;= 2) {
        unsigned char reg = Wire.read();

        switch (reg) {
            // Configuration
            case 0x00:
                Serial.println(&quot;Tried to change the configuration, but it's not handled yet...&quot;);
                break;

            // Set motor speed
            case 0x10:
                // Expecting a 4 byte float value representing
                // angular velocity
                if (Wire.available() &gt;= 4) {
                    unsigned char b0 = Wire.read();
                    unsigned char b1 = Wire.read();
                    unsigned char b2 = Wire.read();
                    unsigned char b3 = Wire.read();
                    motor_speed = bytesToFloat(b0, b1, b2, b3);
                    Serial.print(&quot;Motor speed set to &quot;);
                    Serial.print(motor_speed, 3);
                    Serial.println(&quot; rad/s&quot;);
                }
                break;

            // Set PID gains
            case 0x20:
                // Expecting a 4 byte float value representing
                // proportional gain for the PID
                if (Wire.available() &gt;= 4) {
                    unsigned char b0 = Wire.read();
                    unsigned char b1 = Wire.read();
                    unsigned char b2 = Wire.read();
                    unsigned char b3 = Wire.read();
                    gain_p = bytesToFloat(b0, b1, b2, b3);
                    Serial.print(&quot;Proportional gain set to &quot;);
                    Serial.println(gain_p, 3);
                }
                break;
            case 0x21:
                // Expecting a 4 byte float value representing
                // integral gain for the PID
                if (Wire.available() &gt;= 4) {
                    unsigned char b0 = Wire.read();
                    unsigned char b1 = Wire.read();
                    unsigned char b2 = Wire.read();
                    unsigned char b3 = Wire.read();
                    gain_i = bytesToFloat(b0, b1, b2, b3);
                    Serial.print(&quot;Integral gain set to &quot;);
                    Serial.println(gain_i, 3);
                }
                break;
            case 0x22:
                // Expecting a 4 byte float value representing
                // derivative gain for the PID
                if (Wire.available() &gt;= 4) {
                    unsigned char b0 = Wire.read();
                    unsigned char b1 = Wire.read();
                    unsigned char b2 = Wire.read();
                    unsigned char b3 = Wire.read();
                    gain_d = bytesToFloat(b0, b1, b2, b3);
                    Serial.print(&quot;Derivative gain set to &quot;);
                    Serial.println(gain_d, 3);
                }
                break;
            
            default:
                Serial.println(&quot;Unexcpected register access over I2C&quot;);
                break;
        }
    }
}
</code></pre>
<a class="header" href="print.html#upload-protocol-for-atmega-328" id="upload-protocol-for-atmega-328"><h3>Upload protocol for ATmega 328</h3></a>
<p>If you understood the tutorial with arduino UNO and want to use the ATmega328, you just have to use PCB with connection show below and implement the code exposed above on the ATmega328. This mocrocontroller is programmed with the ISP Programmer explains in the relative section.</p>
<p>--- PIC OF THE CIRCUIT --- Motor board + H Bridge + MOTOR - DRAW CONNECTION --- After robot's deconstruction</p>
<p><a href="https://github.com/Ecam-Eurobot/Eurobot-2018/tree/arduino-pid/arduino">Github link for code</a></p>
<p>--- <a href="https://">OneDrive link for Altium project</a></p>
<a class="header" href="print.html#arduino-communication-shield---spi-broker" id="arduino-communication-shield---spi-broker"><h2>Arduino Communication Shield - SPI Broker</h2></a>
<blockquote>
<p><em>last updated on May 11, 2018</em></p>
</blockquote>
<p>Motor command communication consists of a two-level interface. ROS communicate via ROS Serial (explained in the appropriate section) implemented on an
arduino UNO and this arduino handle the communication with the four individual motors. To help for connections, we designed an arduino shield gathering
simply all SPI bus connections. The only role of the PCB is deleting redundancy in the SPI bus connections and consequently facilitating the SPI bus
execution. As the PCB is really simple, it implements a bus SPI connection, it requires no explanation.</p>
<p>The utility of this PCB concerns SPI and Ros Serial, you will find more explanation about these subjects in the related section.</p>
<p><img src="electronics/pcb/pictures/Broker_F.jpg" alt="Broker Front View" /></p>
<p><img src="electronics/pcb/pictures/Broker_T.jpg" alt="Broker Top View" /></p>
<p>--- <a href="https://">OneDrive link for Altium project</a></p>
<a class="header" href="print.html#if-we-had-to-redo-it" id="if-we-had-to-redo-it"><h2>If we had to redo it</h2></a>
<blockquote>
<p><em>last updated on May 11, 2018</em></p>
</blockquote>
<p>If we had to design another robot with technologies described, there are some decision that we would change.</p>
<ul>
<li>PCB Design</li>
</ul>
<p>The ECAM installation for PCB printing is very useful for prototyping. It is not comparable with PCB that specialised company can create. So, our advice is the following, as soon as a board is functional and definitive, send it to
have a proper and reliable board. Moreover, try to reach this step as soon as possible.</p>
<ul>
<li>Connection</li>
</ul>
<p>We have underestimated the connection on the different board. Regarding the JST connector, they are solid but hard to disconnect and cable creation is  long without the right tool. About the 10 pins shrouded header, they are not
reliable enough. Opposite to the JST, disconnection is too easy. We really  advise against its use. They were the source of a lot of problems. About the SPI connector (10 pins shrouded header) it was not strong enough. The contact
failure brought a lot of problems in the communication between ROS  serial and ATmega.</p>
<p>In the two situations, we advise against the use of these two types of connector, there are a lot of alternative solutions.</p>
<p><img src="electronics/pcb/pictures/JST_Connector.jpg" alt="JST connector" /></p>
<p><img src="electronics/pcb/pictures/10Pins_shroudedHeaders.jpg" alt="10 pins shrouded headers" /></p>
<a class="header" href="print.html#fpga" id="fpga"><h1>FPGA</h1></a>
<a class="header" href="print.html#a-fpga" id="a-fpga"><h2>A. FPGA</h2></a>
<a class="header" href="print.html#a1fpga-what-is-it" id="a1fpga-what-is-it"><h2>1.FPGA: What is it?</h2></a>
<p><strong>Field Programmable Gate Array</strong> - Programmable Gate System These are programmable (or rather reconfigurable) integrated circuits
many times and more and more dynamically!
<strong>They allow</strong>
Either to simulate a circuit to validate it before silicon etching
Either to implement a complete system, System on Chip (SoC)
By using dynamic reconfiguration, this system can become adaptive as needed (acceleration of selected features).</p>
<a class="header" href="print.html#a11-introduction" id="a11-introduction"><h3>1.1. Introduction:###</h3></a>
<p>FPGAs consist of a matrix of programmable logic blocks surrounded by programmable output input blocks. The whole is connected by a programmable interconnection network.
FPGAs are distinct from other programmable circuit families while offering the highest level of logical integration.</p>
<p>There are 4 main categories available commercially:</p>
<p>Symmetrical table.
In column.
Seas of doors.
Hierarchical PLDs.</p>
<p><img src="img/electronics/fpga/image9.png" alt="z" /></p>
<a class="header" href="print.html#a12fpga-structure" id="a12fpga-structure"><h3>1.2.FPGA structure</h3></a>
<p>The specifications of an FPGA often include the number of configurable logic blocks, the number of logic blocks of frozen functions such as multipliers and the size of the memory resources such as the embedded RAM block. An FPGA integrated circuit is composed of several other elements, but these are typically the most important when it comes to choosing and comparing FPGAs for a specific application.</p>
<p>Configurable logic blocks (CLBs) are the basic logical unit of an FPGA. Sometimes called &quot;slices&quot; or &quot;logical cells&quot;, logical blocks consist of two parts: flip-flops and correspondence tables (LUTs). The way flip-flops and LUT lookup tables are assembled differs depending on the types of FPGAs, so it's important to understand their features.</p>
<p><img src="img/electronics/fpga/image10.png" alt="z" /></p>
<a class="header" href="print.html#a13the-possibilities" id="a13the-possibilities"><h3>1.3.The Possibilities</h3></a>
<p>With an FPGA you are able to create the actual circuit, so it is up to you to decide what pins the serial port connects to. That also means you can create as many serial ports as you want. The only limitations you really have are the number of physical I/O pins and the size of the FPGA.
Just like microcontrollers that have a set amount of memory for your program, FPGAs can only emulate a circuit so large.
One of the very interesting things about FPGAs is that while you are designing the hardware, you can design the hardware to be a processor that you then can write software for! In fact, companies that design digital circuits, like Intel or nVidia, often use FPGAs to prototype their chips before creating them.</p>
<p>FPGA continues to dominate as the evolution of high-level tools allows engineers and scientists to enjoy the benefits of reprogrammable circuits, regardless of their level of experience. For more information on using FPGAs in different industries and applications</p>
<a class="header" href="print.html#bspi" id="bspi"><h2>B.SPI</h2></a>
<a class="header" href="print.html#a1-introduction" id="a1-introduction"><h2>1 INTRODUCTION</h2></a>
<p>The protocol that we will use is called Serial Peripheral Interface (SPI). It is a synchronous full-duplex serial interface and is commonly used to communicate with on-board peripherals such as EEPROM, FLASH memory, A/D converters, temperature sensors, or in our case a Field Programmable Gate Array (FPGA).
We assume a working knowledge of the VHDL hardware description language.</p>
<a class="header" href="print.html#a2-hardware" id="a2-hardware"><h2>2 HARDWARE</h2></a>
<p>SPI is a protocol, in which one device (the master) controls one or more other devices (the slaves). For the master we use an open-source microcontroller prototyping platform, such as the Arduino 101 or a modified Arduino UNO R3. In this document we use Arduino to refer to either platform.
The slave can be a low-cost FPGA prototyping platforms, such as the Xilinx Spartan-6 Avnet LX9 or the Altera Cyclone-IV Terasic DE10-Lite . The repository  includes project files and pin assignments for both these boards. The code is written in VHDL and should work equally well on more powerful boards.</p>
<a class="header" href="print.html#a21voltage-levels" id="a21voltage-levels"><h3>2.1.Voltage levels</h3></a>
<p>It is very important that the I/O voltage levels of the devices match. Both FPGA boards support 3.3V levels, and are a good match for the Arduino 101. However, the Arduino UNO uses the traditional 5 Volt TTL levels. Instead of using a level shifter, such as the 74LVC245, we opt for converting the Arduino to 3.3V according to Adafruit’s instructions. Running a 16 MHz clock at 3.3V is out of spec. Is said to work, but should really program the fuses to get the frequency down to abt. 13 MHz .</p>
<a class="header" href="print.html#a22signals" id="a22signals"><h3>2.2.Signals</h3></a>
<p>The SPI interface is a 4 wire interface. The bus consists of 3 signals plus <em>a slave select</em> signal for each device.</p>
<p><em>SCLK</em>: clock signal sent from the master to all slaves.</p>
<p><em>MOSI</em>: serial data from the master to the slaves (Master Out-Slave In).</p>
<p><em>MISO</em>: serial data from a slave to the master (Master In-Slave Out).</p>
<p><em>SS</em>:  slave select signal for each slave.</p>
<p>Once the Arduino runs at 3.3V, connecting the two devices becomes trivial.</p>
<a class="header" href="print.html#a221-pin-outs" id="a221-pin-outs"><h3>2.2.1. Pin outs</h3></a>
<p><img src="img/electronics/fpga/image1.png" alt="z" /></p>
<a class="header" href="print.html#a222-the-physical-connections" id="a222-the-physical-connections"><h3>2.2.2. The physical connections</h3></a>
<p><img src="img/electronics/fpga/image2.png" alt="z" /></p>
<a class="header" href="print.html#a3-byte--protocol" id="a3-byte--protocol"><h2>3. BYTE – PROTOCOL</h2></a>
<p>With the two devices physically connected, we need a protocol to transfer data. We chose the Serial Peripheral Interface (SPI), a lightweight protocol to connect one master to one or more slaves.</p>
<a class="header" href="print.html#a31-masterslave" id="a31-masterslave"><h3>3.1 Master/slave</h3></a>
<p>The SPI bus is controlled by a master device (typically a microcontroller) that orchestrates the bus access. The master generates the control signals and regulates the data flow. The illustration below shows a master with three slaves. The master uses the Slave Select (SS) signal to select the slave.</p>
<p><img src="img/electronics/fpga/image3.png" alt="z" /></p>
<a class="header" href="print.html#a32-parameters" id="a32-parameters"><h3>3.2 Parameters</h3></a>
<p>SPI is also a protocol with many degrees of freedom. It is important that the master and slave agree on the voltage levels and maximum clock frequency. The SPI clock polarity (CPOL) and clock phase (CPHA) introduce four more degrees of freedom as shown in the table below.
SPI parameters</p>
<p><img src="img/electronics/fpga/image4.png" alt="z" /></p>
<p>For this article we assume <em>mode 3</em>, where the clock is high when idle; data is driving following the falling edge of the clock and latched on the rising edge.</p>
<a class="header" href="print.html#a33-operation" id="a33-operation"><h3>3.3. Operation</h3></a>
<p>The protocol is easiest explained with shift registers as shown in the illustration below. The master generates the SPI Clock (<em>SCLK</em>) to initiate the information exchange. Data is shifted on one edge of this clock and is sampled on the opposite edge when the data is stable.</p>
<p><img src="img/electronics/fpga/image5.png" alt="z" /></p>
<p>In mode 3, at the falling edge of <em>SCLK</em>, both devices drive their most significant bit (<em>b7</em>) on their outgoing data line. On the rising edge, both devices clock in this bit into the least significant bit position (<em>b0</em>). After eight <em>SCLK</em> cycles, the master and slave have exchanged their values and each device processes the data received (e.g. writing it to memory). In case there is more data to be exchanged, the registers are loaded with new data and the process repeats itself. Once all data is transmitted, the master stops the <em>SCLK</em> clock.</p>
<a class="header" href="print.html#a34-slave-select" id="a34-slave-select"><h3>3.4. Slave select</h3></a>
<p>For a more complete picture, we need to include the effect of the <em>slave select</em> (<em>SS</em>*) signal that is used to address the slave devices.</p>
<p><img src="img/electronics/fpga/image6.png" alt="z" /></p>
<p>Slaves may only drive their output (<em>MISO</em>) line when <em>SS</em>* is active, otherwise they should tri-stated the output. The protocol can be broken down into the following steps:</p>
<ol>
<li>
<p>The master initiates the communication by activating SS*</p>
</li>
</ol>
<ul>
<li>The slave responds by starting to drive its MISO output.</li>
</ul>
<ul>
<li>
<p>Meanwhile the master drives its MOSI output.</p>
</li>
</ul>
<ol start="2">
<li>
<p>The master makes SCLK low.</p>
</li>
</ol>
<ul>
<li>
<p>On this falling edge, the master and slave drive their most significant bit position (b7) on respectively their MOSI and MISO outputs.</p>
</li>
</ul>
<ol start="3">
<li>
<p>The master makes SCLK high.</p>
</li>
</ol>
<ul>
<li>
<p>On this rising edge, the master and slave clock the input from their respectively MISO and MOSI inputs into the least significant bit position (b0).</p>
</li>
</ul>
<ol start="4">
<li>
<p>Go back to step 2. Until the least significant bit position (b0) has been sent.</p>
</li>
<li>
<p>When all bits are transmitted, the master deactivates SS*.</p>
</li>
</ol>
<a class="header" href="print.html#a4-bytes-exchange-with-arduino-as-master" id="a4-bytes-exchange-with-arduino-as-master"><h2>4. BYTES EXCHANGE WITH ARDUINO AS MASTER</h2></a>
<p>The Arduino is blessed with a support library for the serial peripheral interface. This greatly aids the implementation. For the slave we used an Altera or Xilinx based FPGA implementation . Refer to the first part of this article for details about the physical connection.</p>
<a class="header" href="print.html#a5-byte-exchange-with-a-fpga-as-slave" id="a5-byte-exchange-with-a-fpga-as-slave"><h2>5. BYTE EXCHANGE WITH A FPGA AS SLAVE</h2></a>
<p>Implementing the SPI Slave on an FPGA is like old school digital electronics. My key takeaway is to think hardware, not programming. Implementing the <a href="https://coertvonk.com/hw/logic/connecting-fpga-and-arduino-using-spi-13067/3">SPI protocol</a> on a FPGA is fairly straightforward for as long as we use a directly clocked sequential circuit while preventing clock domain crossings.</p>
<a class="header" href="print.html#a51-sequential-circuit" id="a51-sequential-circuit"><h3>5.1. Sequential circuit</h3></a>
<p>In real life, two signals going to a single gate will not arrive there at the same time due to wire delays. This causes the output to momentarily have an incorrect value. The problem compounds as the signal travels through more gates and wires.</p>
<p>In Building Math Hardware we created elementary math operations using combinatorial circuits. That was OK, because we didn’t care about such output <em>glitches</em> caused by the input signals propagating to the outputs. From a demonstrator’s point of view it even made it more interesting. Talking to a real device, such as a SPI master is different, because it requires the outputs to be stable at certain times.</p>
<p><img src="img/electronics/fpga/image7.png" alt="z" /></p>
<p>The solution is to introduce a clock signal, and store the signals in a flip-flop (registers) at the rising edge of that clock signal. We then only need to ensure that the longest delay from one flip-flop to the next is less that the clock period. This greatly simplifies the design process, at the cost of introducing some delay.</p>
<a class="header" href="print.html#a52-clock-domain" id="a52-clock-domain"><h3>5.2. Clock domain</h3></a>
<p>Field programmable gate arrays thrive on synchronous designs, but they don’t do well with clock signals that are asynchronous with its system clock.</p>
<p>We also need to avoid transferring data from a <a href="https://coertvonk.com/family/school/inquiries/computer-math-inquiry-4245">flip-flop</a> driven by one clock to a flip-flop driven by another clock. This is called a <em>clock domain crossing</em> and might manifest itself in <em>metastability</em>, data loss or incoherence .We prevent clock domain crossings, by synchronizing the input signals to the FPGA clock using a traditional two-stage shift register as illustrated above.</p>
<ul>
<li>
<p>The first flip-flop creates a synchronous version of the inputs by clocking it with the system clock. The input signal could change within the flip-flop’s <em>setup and hold times</em> and may take longer than a system clock cycle to settle to a stable value (metastability). That’s why it is ran through a second flip-flop.</p>
</li>
<li>
<p>The second flip-flop, makes it is very unlikely that this metastability propagates to the output.</p>
</li>
<li>
<p>Adding a third flip-flop gives us access to the previous value. Using the current and previous values, we can generate rise and fall signals as sown below.</p>
<p><img src="img/electronics/fpga/image8.png" alt="z" /></p>
</li>
</ul>
<a class="header" href="print.html#a53-operation" id="a53-operation"><h3>5.3. Operation</h3></a>
<p>The main data object is an 8-bit register called DATA.</p>
<p>On a falling SCLK edge, the most significant bit from data is clocked into a register from where it is transmitted over its MISO output.</p>
<p>On a rising SCLK edge, the MOSI input is shifted into the least significant bit of data.</p>
<p>Once all eight bits are received, the byte is available as rx. This received byte rx should be read when rx Valid is active during a rising edge of the sysClk.</p>
<a class="header" href="print.html#a6-message-exchange-protocol" id="a6-message-exchange-protocol"><h2>6. MESSAGE EXCHANGE PROTOCOL</h2></a>
<p>The time has come to implement a status and register interface on top of the raw byte exchange. We define a few commands to retrieve the device status and access its 32-bit registers.</p>
<a class="header" href="print.html#a61-commands" id="a61-commands"><h3>6.1. Commands</h3></a>
<p>The first byte is defined as the command byte. The interpretation of the remaining bytes (if any) depends on this command. After the command is completed, a new command can be sent. The following commands will be supported:</p>
<ul>
<li><strong>Read status (0x00)</strong>: Reads the status byte.</li>
</ul>
<p>First the master sends 0x00, and ignores the value returned;</p>
<p>the master then sends one dummy byte, to get the 8-bit status value in return.</p>
<ul>
<li><strong>Read register (0x80 to 0x8F)</strong>: Reads the value stored in one of the sixteen registers.</li>
</ul>
<p>The least significant four bits of the command indicate the register to read from.
First the master sends this command, and ignores the value returned,then the master sends 4 dummy bytes to get the 32-bit register value. The first byte received is the most significant, the fourth is the least significant (network byte order).</p>
<ul>
<li>
<p><strong>Write register (0xC0 to 0xCF)</strong>: Writes a value to one of the sixteen registers. The least significant four bits indicate the register to write to.</p>
<ul>
<li>First the master sends the command, and ignores the value returned;</li>
<li>Then the master sends 4 bytes with the value to write. The most significant byte is sent first, the least significant last.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#a62-registers" id="a62-registers"><h3>6.2. Registers</h3></a>
<p>The FPGA will implement two register types. The first 4 registers (0-3) are <em>read/write</em> and can be used to send information to the FPGA. The next 12 registers (4-15) are <em>read-only</em> to receive information from the FPGA. In the greater scheme, the <em>read/write</em> registers will be used to send math operands to the FPGA, and the read-only registers will be used to read the results from the FPGA.</p>
<a class="header" href="print.html#a63-room-for-improvement" id="a63-room-for-improvement"><h3>6.3. Room for improvement</h3></a>
<p>The protocol leaves some room for improvement. It can be made more efficient by implementing continuous commands. Here the master issues a <em>read</em> or <em>write register start</em> command, but keeps sending sets of 4-bytes until it has enough. Along similar lines one could implement commands to access attached memory.</p>
<a class="header" href="print.html#a7-messages-exchange-with-arduino-as-master" id="a7-messages-exchange-with-arduino-as-master"><h2>7. MESSAGES EXCHANGE WITH ARDUINO AS MASTER</h2></a>
<p>Again, we’ll use the support library for the serial peripheral interface. The code shown below was tested on a 3.3 Volt Arduino UNO R3 connected to FPGA implementation.</p>
<a class="header" href="print.html#this-section-aims-to-show-how-different-communication-techniques-have-been-implemented" id="this-section-aims-to-show-how-different-communication-techniques-have-been-implemented"><h2>This section aims to show how different communication techniques have been implemented</h2></a>
<a class="header" href="print.html#i2c" id="i2c"><h1>I2C</h1></a>
<blockquote>
<p><em>last updated on May 10, 2018</em></p>
</blockquote>
<p>The 2017 team had some problems with this bus of data. After some tests, we decided not to use the I2C as a our communication system. Maybe next year ...</p>
<a class="header" href="print.html#serial-peripheral-interface-spi" id="serial-peripheral-interface-spi"><h1>Serial Peripheral Interface (SPI)</h1></a>
<blockquote>
<p><em>last updated on May 10, 2018</em></p>
</blockquote>
<a class="header" href="print.html#quick-theoretical-reminders" id="quick-theoretical-reminders"><h2>Quick theoretical reminders</h2></a>
<p>The Serial Peripheral Interface bus (SPI) is a synchronous serial communication interface specification used for short distance communication, primarily in embedded systems.</p>
<p>You can see on the picture below the topology of this communictaion interface and the pinout of the components:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/SPI_three_slaves.svg/363px-SPI_three_slaves.svg.png" alt="" /></p>
<p>SPI only defines the physical and data link layer of OSI network model. The connection and media between the devices indicates the physical layer. Data link layer defines the way in which the devices are connected. The connections include the input and output lines such as clock, data in and data out. Data link layer in SPI is implied in the connection itself and no provision is made for location or address information.</p>
<p>The communiction frame is writen for the use (Layer three on OSI Model). To begin a communication with a <em>Slave</em>, the <em>Master</em> must fix the Slave Select pin (SS) to <strong>LOW</strong> state. After that, the master can put some bits into the shift register throught the MOSI  (Master Output Slave Input) pin.
When the communication is done, it's the master who must put back the SS to <strong>HIGH</strong> State.</p>
<blockquote>
<p><strong>Note</strong> :
It's a full duplex interface, The slave can push some data on his MISO (Master Input Slave Output) pin during the communication.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/SPI_8-bit_circular_transfer.svg/500px-SPI_8-bit_circular_transfer.svg.png" alt="" /></p>
<a class="header" href="print.html#advantages" id="advantages"><h3>advantages</h3></a>
<ul>
<li>Full duplex communication</li>
<li>Flexibility of the number of bits to be transmitted as well as the protocol itself</li>
<li>no possible collision</li>
</ul>
<a class="header" href="print.html#disadvantage" id="disadvantage"><h3>disadvantage</h3></a>
<ul>
<li>(3 + N*Slaves) pins are required on the master</li>
<li>4 pins are required on each slaves</li>
<li>Master can speak in a vacuum without knowing it</li>
<li>Bus can only count one master</li>
</ul>
<a class="header" href="print.html#use-of-our-spi" id="use-of-our-spi"><h2>Use of our SPI</h2></a>
<p>the communication frame we used to send data to the slave is:</p>
<ol>
<li>Register adress on 8 bits</li>
<li>Number of bytes composing the message</li>
<li>Message</li>
</ol>
<blockquote>
<p><strong>Note</strong> :
to read some data from a slave's register, the master must just send the register adress. The slave push the data on his MISO (Master Input Slave Output) pin.</p>
</blockquote>
<a class="header" href="print.html#our-master" id="our-master"><h3>Our Master</h3></a>
<p>Create a SPI Master is really easy with a atmega328p and the arduino IDE. Indeed, we can find easily some libraries. We used the one provided directly by the arduino IDE in an object that we implemented : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a></p>
<p>how to work with <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a> object will be illustrated at least code use for Cortex's engines control (Eurobot 2018) : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/Ecam/examples/MotorControl/MotorBroker/MotorBroker.ino">MotorBroker</a></p>
<a class="header" href="print.html#a1-initialisation-of-the-spi-communication" id="a1-initialisation-of-the-spi-communication"><h5>1. Initialisation of the SPI communication</h5></a>
<p>The <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a> object must be seen as a communication channel with the slave. It will be necessary to instantiate one <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a> object by slave. When creating the object, use the number of the SS pin as an argument.</p>
<pre><code class="language-c">//Define the SS pin for each slave
#define FL_SS  9
#define FR_SS  2
#define BL_SS  10
#define BR_SS  3

//Object Instantiation
SPIManager connFL(FL_SS);
SPIManager connFR(FR_SS);
SPIManager connBL(BL_SS);
SPIManager connBR(BR_SS);
</code></pre>
<p>Use the <em>initialize()</em> method to activate the communication channel. This call should be placed in the <em>setup()</em> function of the arduino code.</p>
<pre><code class="language-c">connFL.initialize();
</code></pre>
<a class="header" href="print.html#a2-write-data-to-a-slaves-register" id="a2-write-data-to-a-slaves-register"><h5>2. Write data to a Slave's register</h5></a>
<p>as said above, to write a value in a register of the slave will first send the address of the register, then the size in number of byte and to finish, the message.</p>
<p>The <em>writedata</em> function has been written to make its use as intuitive as possible.
below, an example of use where we send to the register <strong>16</strong> (0x10), the message <strong>x.b</strong> whose size is <strong>4 bytes</strong>.</p>
<pre><code class="language-c">connBR.writeData(0x10, 0x04, x.b);
</code></pre>
<a class="header" href="print.html#a3-read-data-from-a-slaves-register" id="a3-read-data-from-a-slaves-register"><h5>3. Read data from a Slave's register</h5></a>
<p>There are two functions to read some data: the first,<em>readLongData</em> , will return a value of type <strong>long</strong> and the other ,<em>readData</em> , a value of type <strong>float32</strong></p>
<p>below, an example of use where we get some data from th register <strong>81</strong> (0x51).</p>
<pre><code class="language-c">encoders_msg.rear_left = connBL.readLongData(0x51);
</code></pre>
<a class="header" href="print.html#our-slaves" id="our-slaves"><h3>Our Slaves</h3></a>
<p>When using the Arduino IDE to program atmeg328p, the slave mode is not available. Two registers must be modified to <em>activate</em> this mode :</p>
<pre><code class="language-c">// turn on SPI in slave mode
SPCR |= _BV(SPE);
// turn on interrupts
SPCR |= _BV(SPIE);
</code></pre>
<p>So that these manipulations are transparent for the user we also create an object for the SPI bus slaves : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIslave.cpp">SPISlave</a></p>
<p>this object has several methods :</p>
<ol>
<li><strong>begin()</strong> : change the two registers cited above and declaring the MISO pin as an output.</li>
<li><strong>reset()</strong> : reset private object variables.</li>
<li><strong>com()</strong>: manage the communication by putting the incoming data in the right variables.</li>
</ol>
<p>and some properties :</p>
<ol>
<li><strong>command</strong> : return the register address.</li>
<li><strong>dataSize</strong> : return the size of the incoming message.</li>
<li><strong>msg</strong> : return the message (maximum 64 bits).</li>
<li><strong>endtrans</strong> : boolean that returns <strong>true</strong> if communication is complete.</li>
</ol>
<a class="header" href="print.html#a1-initialisation-of-the-spi-communication-1" id="a1-initialisation-of-the-spi-communication-1"><h5>1. Initialisation of the SPI communication</h5></a>
<p>The MOSI, MISO and SLK pin are always the same on arduino. If you want you can change the SS pin number we agree to use pin 10 as pin SS for the slave.</p>
<blockquote>
<p><strong>Note</strong> :
SS is a reserved name used for the SPI communication.</p>
</blockquote>
<p>On the begin of our script we create a SPI object and define the SS pin number as it's done in the following code :</p>
<pre><code class="language-c">SpiSlave mySPI;

//SLK  : pin 13
//MISO : pin 12
//MOSI : pin 11 
#define SS 10
</code></pre>
<p>to enable the communication, use the <em>begin()</em> method of the SPISlave object in the <em>setup()</em> function of the atemega :</p>
<pre><code class="language-c">void setup()
{
    mySPI.begin();
}
</code></pre>
<a class="header" href="print.html#a2-interruption" id="a2-interruption"><h5>2. Interruption</h5></a>
<p>An incoming call performed by the master to the slave triggers an interrupt. In most cases, the method in which the interrupt routine will be placed will be: <strong>ISR (name _of _a _register)</strong>. in our case the register will be <strong>SPI _VTC _vect</strong>. As we work whith an atemega328p the shift register is called : <strong>SPDR</strong>.</p>
<p>This way of working is illustrated in the following code :</p>
<pre><code class="language-c">//Interrupt needed by SPI Communication
ISR (SPI_STC_vect) {
    //manage the communication by putting the incoming data in the right variables.
    mySPI.com(SPDR);
    //Method containing the registers of the Slave. 
    spiReg();   
}
</code></pre>
<a class="header" href="print.html#a3-registers" id="a3-registers"><h5>3. Registers</h5></a>
<p>A <strong>SWITCH</strong> is commonly used to define the registers. In our case of use, it is the <em>command</em> property of the <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIslave.cpp">SPISlave</a> object which is used as parameter of the <strong>SWITCH</strong>.</p>
<p>the writing in a register will be done once the communication is finished (thanks to the property <em>endTrans</em>). This method of work has the advantage of not having inconsistent values during the communication.</p>
<p>The reading of a registers uses the full-duplex channel provided by the SPI. The data are pushed through the channel during the communication using the <strong>SPDR</strong> register.</p>
<p>Here is an example of a function that contains the registers of a slave:</p>
<pre><code class="language-c">void spiReg(){  
switch (mySPI.command) {
  case 0x10:
      if(mySPI.endTrans) {
          for (int i = 0; i &lt; 4; i++){
              motor_speed.b[i] = mySPI.msg[i];
           }
       }
      break;
   case 0x11:
      SPDR = motor_speed.b[mySPI.dataCount - 2];
      break;
   case 0x50:
      motor_encoder.write(0);
      break;    
   case 0x51:
      SPDR = EncoderState.b[mySPI.dataCount - 2];
      break;    
  } 
}
</code></pre>
<a class="header" href="print.html#troubleshooting-1" id="troubleshooting-1"><h3>Troubleshooting</h3></a>
<blockquote>
<p>Patched but not fixed</p>
</blockquote>
<a class="header" href="print.html#a1-problem-between-serial-port-rosserial-and-spi-bus" id="a1-problem-between-serial-port-rosserial-and-spi-bus"><h5>1. Problem between serial port (ROSSERIAL) and SPI bus</h5></a>
<p>There is a competition between Rosserial and the SPI since both use the serial bus. when one ROS sends a data via the serial port, the communication SPI is interrupted.</p>
<p>Patch : simply initialize the SPI communication before each data transfer</p>
<pre><code class="language-c">void message_to_FR( const std_msgs::Float32 &amp; toggle_msg){
    x.val = toggle_msg.data;
    connFR.initialize();
    connFR.writeData(0x10, 0x04, x.b);
}
</code></pre>
<a class="header" href="print.html#a2-sometimes-the-slave-update-the-value-of-a-register-with-the-value-received-previously" id="a2-sometimes-the-slave-update-the-value-of-a-register-with-the-value-received-previously"><h5>2. sometimes the slave update the value of a register with the value received previously</h5></a>
<p>we observed that sometimes the received data are updated with a delay of ONE communication. The problem is that if the time between two communications is long, there will be latency before the update in the registry.</p>
<p>Patch : The data is sent by ROS every 50ms even if it is not changed (see on <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/ros_packages/mecanum/src/motor_sim.py">motor_sim.py</a>)</p>
<a class="header" href="print.html#a3-changing-the-values-of-a-register-when-reading-another-register" id="a3-changing-the-values-of-a-register-when-reading-another-register"><h5>3. Changing the values of a register when reading another register</h5></a>
<p>When we want to read the return of a slave encoder we send a series of null bytes after the address byte to receive the value. But these null values are misinterpreted and the engine speed drops to zero. Probably from a coding error.</p>
<p>Patch : We send velocity value instead of null bytes. (just using during the Eurobot sprint)</p>
<a class="header" href="print.html#just-for-curious" id="just-for-curious"><h1>Just for curious.</h1></a>
<p><a href="https://github.com/Sellto/SPIandROS_HelloWord">https://github.com/Sellto/SPIandROS_HelloWord</a></p>
<p>Three simples scripts to train you with ours SPI objects and with or without rosserial communication.</p>
<p>Decription of the situation :</p>
<ul>
<li>The two slaves has a LED connected to pin 4 whose state is modifiable by a SPI register.</li>
<li>The master is connected to ROS which controls the flashing speed of each led.</li>
</ul>
<p>Video-Tuto : ASAP</p>
<a class="header" href="print.html#references-2" id="references-2"><h1>References</h1></a>
<p><a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</a></p>
<a class="header" href="print.html#why-using-canbus-on-the-robots-and-how-to-implement-it" id="why-using-canbus-on-the-robots-and-how-to-implement-it"><h1>Why using CANBus on the robots and how to implement it</h1></a>
<a class="header" href="print.html#issues-and-context-of-the-eurobot--2018-" id="issues-and-context-of-the-eurobot--2018-"><h2>Issues and context of the Eurobot ( 2018 )</h2></a>
<p>Many technologies have been implemented on the robots for the 2018 edition of the EUROBOT.</p>
<p>Those technologies were a huge step forward in terms of quality, speed and ease of use.</p>
<p>However, unexpected downsides appeared during the implementation of the technologies on the robots.</p>
<p>Thoses downsides are of all type but those who are speaking about during this tutorial are *<em>electronic</em> and <strong>space</strong>.</p>
<p><img src="electronics/communication/CAN_SRC/complex-wiring.png" alt="alt text" title="Logo Title Text 1" /></p>
<a class="header" href="print.html#electronic-problem" id="electronic-problem"><h3>Electronic problem</h3></a>
<p>Once the boards are installend on the robots, they needed a lot of connections between them. The last picture shows the kind of result we got after connecting all the wires.</p>
<p>From that moment it is very complex to add or remove wires because of the big amount of cables.</p>
<p>It is also very complex for the debugging because it is hard to take measures and to find where the error is.</p>
<a class="header" href="print.html#space-problem" id="space-problem"><h3>Space problem</h3></a>
<p>Another problem wich appeared and that we didn't is the huge space taken by the wires.</p>
<p>During the conception the <strong>mistake</strong> we did is to disregard the size of the wires. In the future, some leeway should be taken on the size of the robot during the conception.</p>
<p>The huge number of wires had also an mechanical impact. It added constraint on the connexions wich often broke.</p>
<a class="header" href="print.html#le-canbus" id="le-canbus"><h2>Le CANBus</h2></a>
<a class="header" href="print.html#context" id="context"><h3>Context</h3></a>
<p>Those problems have already been met many years ago in the automotive. Indeed, more and more electronic devises were used in the cars for differents purposes :</p>
<ul>
<li>Engine temperature, air...</li>
<li>RPM, speed...</li>
<li>accelerometer...</li>
<li>Safety, ABS, Airbag, opened doors, seatbelt...</li>
</ul>
<a class="header" href="print.html#specifications-1" id="specifications-1"><h3>Specifications</h3></a>
<p>We can cleary see that with the number of wires increasing the wiring harness became a real problem.</p>
<p>To resolve this, BOSCH developped the CANBus with several caracteristics :</p>
<ul>
<li>High speed communication up to 1 Megabit/s (see the table below for more information)</li>
<li>Real time ( wich makes CANBus better than TCP/IP)</li>
<li>Error detection, fast recovery and repair ( stil in real time)</li>
<li>Security and stability</li>
<li>Priorization of transmission</li>
<li>Based on a differiental signal, the CANBus is made for harsh environnements (External noises and fault tolerance)</li>
<li>It uses a twisted pair cable wich limits the noise emition</li>
</ul>
<p>You can see below the speed transmission according to the distances</p>
<p><img src="electronics/communication/CAN_SRC/can_speed.PNG" alt="alt text" /></p>
<a class="header" href="print.html#topology" id="topology"><h4>Topology</h4></a>
<p>Finally, the biggest benefit of the CANBus is his one bus line topology which limits the number of cables to 4. (CAN HIGH, CAN LOW, VCC and GROUND).</p>
<p>This the reason why it is used on every modern car.</p>
<p><img src="electronics/communication/CAN_SRC/can_topology.png" alt="alt text" /></p>
<p>We can see on the last figure a system without the CANBus (left) and a system with the CANBus (right).</p>
<p>Every component, called a node, is connected to the bus line like the figure below :</p>
<p><img src="electronics/communication/CAN_SRC/can_busnode.jpg" alt="alt text" /></p>
<p>By analogy, the CANBus can be represented by a number of people ( the nodes ) in a room ( the bus line ) where everybody screams his informations. Everyelse has the choice to listen or not. A priority system chooses who is going to speak when several people want to speak at the same time.</p>
<a class="header" href="print.html#the-frame" id="the-frame"><h3>The frame</h3></a>
<p><img src="electronics/communication/CAN_SRC/can_frame.jpg" alt="alt text" /></p>
<p>A data frame is made of different parts :</p>
<ul>
<li>1 dominant bit begins the frame</li>
<li>The ID of the message is made of 11 bits in the standart CAN or 29 bits in the extended CAN.</li>
<li>6 bits which determine the lenght of the frame</li>
<li>The data made of 0...8 bytes</li>
<li>15 bits of CRC to detect errors</li>
<li>ACK</li>
<li>End of frame bit</li>
</ul>
<a class="header" href="print.html#priority-of-transmission" id="priority-of-transmission"><h3>Priority of transmission</h3></a>
<p>When differents nodes whant to talk at the same time on the bus line, it is the ID who is going to determine the priority.</p>
<p>It gives an important advantage to CANBus, it is possible to make priority of transmission by choosing the right ID. For example, in car the brake system is more important than the light system. The ID of the brake system will be lower ( more 0 ) than the light system.</p>
<a class="header" href="print.html#implementation" id="implementation"><h2>Implementation</h2></a>
<a class="header" href="print.html#hardware" id="hardware"><h3>Hardware</h3></a>
<p><img src="electronics/communication/CAN_SRC/can_hardware.png" alt="alt text" /></p>
<p>The last figure shows the implementation of the CANBus. The implementation is quite easy because of the modules proposed by Microchip.</p>
<p>A node is made of a transceiver, a CAN controller and a microcontroller.</p>
<a class="header" href="print.html#transceiver" id="transceiver"><h4>Transceiver</h4></a>
<p>Microchip proposes a lot of solutions for the automotive including a transceiver.</p>
<p>It is the MCP2562. Formerly the MCP2551, is used to convert the TTL signal to a differential signal required by the CANBus.</p>
<a class="header" href="print.html#controller" id="controller"><h4>Controller</h4></a>
<p>Microchip also proposes the CAN controller MCP2515 which implements all the CAN 2.0 specifications. It is able to send and receive data and communicate it via SPI to a microcontroller.</p>
<a class="header" href="print.html#microcontroller" id="microcontroller"><h4>Microcontroller.</h4></a>
<p>Any microcontroller with an integrated SPI communication can be selected.</p>
<p>For example we can take the famous ATMEGA328p known for his arduino IDE.</p>
<a class="header" href="print.html#resistance" id="resistance"><h4>Resistance</h4></a>
<p>In every communication wire there is some reflexion that can corrupt the data. It can be avoided by using 120 Ohm resistor at the end of line.</p>
<a class="header" href="print.html#pcb" id="pcb"><h4>PCB</h4></a>
<p>Coming soon.</p>
<a class="header" href="print.html#software-arduino" id="software-arduino"><h3>Software (Arduino)</h3></a>
<p>There are many libraries that propose functions to interract with the CAN controller via SPI from the micrcontroller.</p>
<p>A very comlete and up to date library is the Seed studio lib :
<a href="https://github.com/Seeed-Studio/CAN_BUS_Shield">https://github.com/Seeed-Studio/CAN_BUS_Shield</a></p>
<a class="header" href="print.html#filters" id="filters"><h4>Filters</h4></a>
<p>Filters allow to choose wich messages will be sent to the microcontroller from the CAN controller.</p>
<p>The MCP2515 is able the define 6 filters. For example :</p>
<pre><code class="language-javascript">CAN.init_Filt(0, 0, 0x04);                          
CAN.init_Filt(1, 0, 0x05);                          
</code></pre>
<p>This code means that the CAN controller will only listen to the messages with an ID of 0x04 and 0x05.</p>
<a class="header" href="print.html#masks" id="masks"><h4>Masks</h4></a>
<p>The masks defines the bits that will be inspected to filter the coming ID. If the bit of the mask is 1, it means that the ID has to respect the bit of the filter.</p>
<p>For example with the following filter :</p>
<pre><code class="language-javascript">0100 1101
</code></pre>
<p>If the mask is :</p>
<pre><code class="language-javascript">1111 1111
</code></pre>
<p>Then it means that the accepted ID has to have exactly the same bits thant the filter because all the masks bits are 1. Only a message witch the next ID will be accepted :</p>
<pre><code class="language-javascript">0100 1101
</code></pre>
<p>Now, if the mask is this one :</p>
<pre><code class="language-javascript">1111 1110
</code></pre>
<p>It means that the filter will not inspect the last bit of the ID.</p>
<p>The next ID's will be accpeted</p>
<pre><code class="language-javascript">0100 1100
0100 1101
</code></pre>
<a class="header" href="print.html#usefull-links" id="usefull-links"><h1>Usefull links</h1></a>
<ul>
<li>Introduction to CANBus by Texas Instrument, <a href="http://www.ti.com/lit/an/sloa101b/sloa101b.pdf">http://www.ti.com/lit/an/sloa101b/sloa101b.pdf</a></li>
<li>CAN specs by BOSCH, <a href="https://www.kvaser.com/software/7330130980914/V1/can2spec.pdf">https://www.kvaser.com/software/7330130980914/V1/can2spec.pdf</a></li>
<li>CANBus implementation with Arduino, <a href="http://www.prometec.net/wp-content/uploads/2015/07/Controller-Area-Network-Prototyping-With-Arduino-Wilfried-Voss.pdf">http://www.prometec.net/wp-content/uploads/2015/07/Controller-Area-Network-Prototyping-With-Arduino-Wilfried-Voss.pdf</a></li>
<li>Well documented on Wikipedia, https://en.wikipedia.org/wiki/CAN_bus</li>
</ul>
<a class="header" href="print.html#software" id="software"><h1>Software</h1></a>
<p>The software is an important part of the Robot. It is often the one that is the most challenging
as to few people work on it. In this part, we are going to introduce you to the software stack of
our robots. We will present the different technologies we used and try to explain many of the concepts
related to them.</p>
<p>In 2018, we build the robots around <strong><a href="http://www.ros.org/">ROS</a></strong>, which is a robotics framework facilitating
software development for robotics. ROS is not easy to start with, but once you get the hang of it, it
greatly improves your productivity. In the <a href="software/ros/ros.html">ROS</a> chapters, we will try to distill the most important
information in order to get you started quickly.</p>
<a class="header" href="print.html#install-docker" id="install-docker"><h1>Install docker</h1></a>
<p>To ease the development process, we recommend installing ROS inside a docker container instead of using a virtual machine. This comes with several advantages like ease of installation, having a common development environment and performance gains while compiling and running code on your computer.</p>
<p>It is important to note that the robot will not use docker and will run ROS packages natively. If you are an expert and know what you are doing, feel free to use your own method to develop ROS packages. Be it inside a virtual machine or a dedicated linux partition on your drive. Otherwise, just stick to the instructions below.</p>
<a class="header" href="print.html#linux" id="linux"><h2>Linux</h2></a>
<p>The installation varies quite a bit depending on the distribution you are using because the repositories are different for each distribution.
For more information, visit <a href="https://docs.docker.com/install/#server">this link</a> and choose your distribution. If your distribution is not listed, try looking at the documentation of your own distribution.</p>
<a class="header" href="print.html#windows" id="windows"><h2>Windows</h2></a>
<p>On windows, you can download and install <a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe">this executable</a>.
Once the docker app is installed, run it and you should see the docker icon in your system tray. Always make sure the service is up and running before trying to do anything with it.</p>
<p>For more information, follow <a href="https://docs.docker.com/docker-for-windows/install/#install-docker-for-windows-desktop-app">this link</a>.</p>
<a class="header" href="print.html#macos" id="macos"><h2>macOS</h2></a>
<p>Download and run <a href="https://download.docker.com/mac/stable/Docker.dmg">this image</a>. When asked, drag and drop the docker.app whale icon to the application folder. Once it is finished, simply start the docker service by running the docker app. You should see the docker icon in your system tray. Always make sure the service is up and running before trying to do anything with it.</p>
<p>For more information, follow <a href="https://docs.docker.com/docker-for-mac/install/">this link</a>.</p>
<a class="header" href="print.html#download-the-ros-container" id="download-the-ros-container"><h1>Download the ROS container</h1></a>
<p>Once docker is properly installed and the service is running, we can download the ROS image.
To begin, open a terminal (or docker cmd on windows) and enter the following command: <code>docker pull ros</code>
This will start the download of the official ROS image from the docker hub.</p>
<a class="header" href="print.html#run-the-container" id="run-the-container"><h1>Run the container</h1></a>
<p>When all of the files have been downloaded, run the container with the following command:
<code>docker run -it --name=robot ros</code>.</p>
<p>This command does several things. First of all, <code>docker run</code> creates a new container based on the ROS image we just downloaded and starts it. The <code>-it</code> parameter spins up an interactive bash shell inside the container and attaches it to the current terminal. Finally, the <code>--name=robot</code> renames the container to something easy we can work with later. You can give this any name you'd like.</p>
<p>You now have a functionning ROS environment.
To exit the container, use <kbd>ctrl</kbd> + <kbd>d</kbd> or type <code>exit</code> in the terminal.</p>
<p>Now, if we want to get back into the container we were just using, we can't use the same command as above as it will again create a new container just like before and all our modifications would be lost.
Instead we need to start the previous container again and attach to it. This can be done with the following command:
<code>docker start robot &amp;&amp; docker attach robot</code>
The <code>&amp;&amp;</code> tells our shell to execute the second command once the first one completed successfully.</p>
<p>You should now be back into the bash shell inside the container.
To start working on ROS projects, we recommend creating an appropriate workspace inside the /home/ros directory like so:
<code>mkdir -p /home/ros &amp;&amp; cd /home/ros</code></p>
<p>You can now follow the instructions to <a href="software/ros/basics/workspace.html">setup your workspace</a>.</p>
<a class="header" href="print.html#additional-notes" id="additional-notes"><h1>Additional notes</h1></a>
<a class="header" href="print.html#run-multiple-shells-inside-the-container" id="run-multiple-shells-inside-the-container"><h2>Run multiple shells inside the container</h2></a>
<p>By default, only one bash session is running inside the container. Practically, this means that if you try to attach the same container in multiple terminals simultaneously, you won't be able to run separate commands in each.</p>
<p>To fix this -- and this will be needed to launch <code>roscore</code> in background before any other ROS command --  start a new bash session inside the container by typing the following in a new terminal:
<code>docker exec -it robot bash</code></p>
<p>This will start a new bash session inside the already running container and attach to it automatically. If you exit this session, the container will keep running in the background. To stop the container, you will have to exit from the terminal where you started (or attached) to it. You can also stop a container with the command <code>docker stop robot</code>.</p>
<a class="header" href="print.html#ros" id="ros"><h1>ROS</h1></a>
<p>ROS or Robot Operating Systems is an open source framework designed for designing robots.
ROS is commonly installed upon a Linux operating system.
There are different ROS versions:</p>
<ul>
<li>Lunar (Latest)</li>
<li>Kinetic (LTS)</li>
<li>Jade</li>
<li>Indigo</li>
<li>...</li>
</ul>
<p>The ROS distribution we're using for Eurobot is the 'Kinetic' versions.</p>
<p>What's great about ROS, it's that there is an ever growing community that is sharing their code &amp; projects of robotic machines. This is great because there are many build-in/downloadable libraries ready to use and the end user doesn't need to reinvent the wheel for classic robotic manipulations, like for example:</p>
<ul>
<li>Drivers to read/write to sensors</li>
<li>Robotic algorithms (navigation, interpret sensor data, object manipulation)</li>
<li>...</li>
</ul>
<p>In this section we will go over the basic concepts of ROS, the actual installation and the realisation of a project from scratch.</p>
<a class="header" href="print.html#installing-ros" id="installing-ros"><h1>Installing ROS</h1></a>
<p>ROS is only officially supported on Ubuntu or Debian, with other platforms being experimental or unofficial. We recommend installing <a href="https://www.ubuntu.com/download/desktop">Ubuntu</a> for desktops or laptops and <a href="https://ubuntu-mate.org/raspberry-pi/">Ubuntu Mate</a> for the Raspberry Pi.</p>
<a class="header" href="print.html#installing-ros-on-a-raspberry-pi" id="installing-ros-on-a-raspberry-pi"><h2>Installing ROS on a Raspberry Pi</h2></a>
<a class="header" href="print.html#installing-ubuntu-mate" id="installing-ubuntu-mate"><h3>Installing Ubuntu Mate</h3></a>
<p><a href="https://ubuntu-mate.org/download/">Download Ubuntu Mate</a> Xenial 16.04, choosing the Raspberry Pi architecture.</p>
<p>The image is compressed. On Windows you can use a tool like 7-zip to decompress it. On Linux and MacOS you can use the following command:</p>
<pre><code>xz -d filename.xz
</code></pre>
<a class="header" href="print.html#writing-the-sd-card" id="writing-the-sd-card"><h4>Writing the SD card</h4></a>
<p>Now we need to write the image file onto the microSD card.</p>
<p>On <strong>Windows</strong> we can use <a href="https://sourceforge.net/projects/win32diskimager/">Win32 Disk Imager</a>.</p>
<p><img src="img/software/ros/win32diskimager01.png" alt="Win32DiskImager" /></p>
<p>On <strong>Linux</strong> we use the <code>dd</code> command.</p>
<p>First we need to find our SD card using the <code>lsblk</code> command. When you have found the name, you can unmount it.</p>
<pre><code># Find the SD card
lsblk

# Unmount the SD card
sudo umount /dev/sd&lt;?&gt;&lt;?&gt; 

# Copy the image to the SD card
sudo dd if=ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img of=/dev/sd&lt;?&gt; bs=4M
</code></pre>
<p>The <code>dd</code> command will take a long time to complete and does not give any feedback. Be patient...</p>
<p>On <strong>MacOS</strong> we also use the <code>dd</code> command, but it is slightly different than for Linux.</p>
<pre><code># Find the SD card
diskutil list

# Unmount the SD card
sudo umount /dev/disk&lt;?&gt;s&lt;?&gt;

# Copy the image to the SD card
sudo dd if=ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img of=/dev/disk&lt;?&gt; bs=4m
</code></pre>
<p>Once the USB stick is made, boot onto the SD Card and follow the install procedure.
Once Ubuntu is installed, continue with the instructions below.</p>
<a class="header" href="print.html#install-dependencies" id="install-dependencies"><h3>Install dependencies</h3></a>
<p>Install Git.</p>
<pre><code>sudo apt-get install git
</code></pre>
<a class="header" href="print.html#configure-the-raspberry-pi" id="configure-the-raspberry-pi"><h3>Configure the Raspberry Pi</h3></a>
<a class="header" href="print.html#installing-ros-1" id="installing-ros-1"><h3>Installing ROS</h3></a>
<p>Once Ubuntu is installed, we need to configure the sources to accept software from the ROS repositories:</p>
<pre><code>sudo sh -c 'echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list'
sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116
</code></pre>
<p>After that, you can install ROS by issuing the following commands:</p>
<pre><code>sudo apt-get update
sudo apt-get install ros-kinetic-desktop-full
</code></pre>
<p>This may take a while...</p>
<blockquote>
<p><strong>Tip:</strong> To find available ROS packages you can use the following command:</p>
<pre><code>apt-cache search ros-kinetic
</code></pre>
</blockquote>
<a class="header" href="print.html#setup-ros" id="setup-ros"><h3>Setup ROS</h3></a>
<p>Initialize rosdep:</p>
<pre><code>sudo rosdep init
rosdep update
</code></pre>
<p>ROS needs to setup a lot of environment variables to work properly. It is easier if they are loaded automatically
when you launch a terminal. To do this, we copy the setup code into our <code>.bashrc</code> file:</p>
<pre><code>echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<a class="header" href="print.html#install-dependencies-to-build-packages" id="install-dependencies-to-build-packages"><h3>Install dependencies to build packages</h3></a>
<pre><code>sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential
</code></pre>
<a class="header" href="print.html#ros-1" id="ros-1"><h1>Ros</h1></a>
<p>ROS starts with the ROS Master. The Master allows all other ROS pieces of software (Nodes) to find and talk to each other. That way, we do not have to ever specifically state “Send this sensor data to that computer at 127.0.0.1. We can simply tell Node 1 to send messages to Node 2. But... how do Nodes do this? By publishing and subscribing to <code>TOPICS</code>.</p>
<p>The ROS Master provides name registration and lookup to the rest of the Computation Graph.</p>
<p><img src="http://www.clearpathrobotics.com/assets/guides/ros/_images/ros101one.png" alt="alt text" title="ROS GRAPH" /></p>
<blockquote>
<p>This content is based on <a href="https://www.clearpathrobotics.com/">Clearpath Robotics</a> documentation. For further information refer to their <a href="http://www.clearpathrobotics.com/assets/guides/ros/Intro%20to%20the%20Robot%20Operating%20System.html">ROS Tutorials</a>.</p>
</blockquote>
<a class="header" href="print.html#nodes" id="nodes"><h1>Nodes</h1></a>
<p>Nodes are executables that can communicate with other processes using topics,
services, or the Parameter Server. Using nodes in ROS provides us with fault
tolerance and separates the code and functionalities, making the system simpler.</p>
<p>A node must have a unique name in the system. This name is used to permit the
node to communicate with another node using its name without ambiguity.</p>
<p>ROS has tools to handle nodes and give us information about it, such as <code>rosnode</code>.</p>
<p>The rosnode tool is a command-line tool used to display information about nodes,
such as listing the currently running nodes. The supported commands are as follows:</p>
<ul>
<li><code>rosnode info NODE</code>: This prints information about a node</li>
<li><code>rosnode kill NODE</code>: This kills a running node or sends a given signal</li>
<li><code>rosnode list</code>: This lists the active nodes</li>
<li><code>rosnode machine hostname</code>: This lists the nodes running on a particular machine or lists machines</li>
<li><code>rosnode ping NODE</code>: This tests the connectivity to the node.</li>
<li><code>rosnode cleanup</code>: This purges the registration information from unreachable nodes</li>
</ul>
<a class="header" href="print.html#topics" id="topics"><h1>Topics</h1></a>
<p>Topics are buses used by nodes to transmit data. Topics can be transmitted without a
direct connection between nodes, which means that the production and consumption
of data are decoupled. A topic can have various subscribers and can also have
various publishers, but you can take care about publishing the same topic with
different nodes because it can create conflicts.</p>
<p>Each topic is strongly typed by the ROS message type used to publish it, and nodes
can only receive messages from a matching type. A node can subscribe to a topic
only if it has the same message type.</p>
<p>ROS has a tool to work with topics called <code>rostopic</code>. It is a command-line tool
that gives us information about the topic or publishes data directly on the network.
This tool has the following parameters:</p>
<ul>
<li><code>rostopic list</code>: This prints information about active topics.</li>
<li><code>rostopic pub /topic type args</code>: This publishes data to the topic.
It allows us to create and publish data in whatever topic we want,
directly from the command line.</li>
<li><code>rostopic echo /topic</code>: This prints messages to the screen.</li>
<li><code>rostopic find message_type</code>: This finds topics by their type.</li>
<li><code>rostopic info /topic</code>: This prints information about the active topic,</li>
<li><code>rostopic hz /topic</code>: This displays the publishing rate of the topic.
topics published, ones it is subscribed to, and services.</li>
<li><code>rostopic type /topic</code>: This prints the topic type, that is, the type of
message it publishes.</li>
<li><code>rostopic bw /topic</code>: This displays the bandwidth used by the topic.</li>
</ul>
<a class="header" href="print.html#messages" id="messages"><h1>Messages</h1></a>
<p>A node sends information to another node using messages that are published
by topics. The message has a simple structure that uses standard types or types
developed by the user.</p>
<p>Message types use the following standard ROS naming convention; the name of the
package, then /, and then the name of the .msg file. For example, <strong>std_msgs/msg/String.msg</strong> has the <strong>std_msgs/String</strong> message type.</p>
<p>ROS has the <code>rosmsg</code> command-line tool to get information about messages. The
accepted parameters are as follows:</p>
<ul>
<li><code>rosmsg show</code>: This displays the fields of a message</li>
<li><code>rosmsg list</code>: This lists all messages</li>
<li><code>rosmsg package</code>: This lists all of the messages in a package</li>
<li><code>rosmsg packages</code>: This lists all of the packages that have the message</li>
<li><code>rosmsg users</code>: This searches for code files that use the message type</li>
</ul>
<a class="header" href="print.html#workspaces" id="workspaces"><h1>Workspaces</h1></a>
<p>The first thing you will want to do before you write code is create an environnement for your project. This environnement is called <em>Workspace</em>. The Workspace is the root folder containing subfolders and files essential to run your project.
These files will be generated using the <strong>catkin_init_workspace</strong> command.</p>
<p>Let's get into it!
<br><br></p>
<ul>
<li>Choose a directory for your workspace, let's use 'catkin_ws'</li>
</ul>
<pre><code>mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src
catkin_init_workspace
</code></pre>
<p>This will create a <strong>CMakeLists.txt</strong> file in your <strong>/src</strong> folder.
<br><br></p>
<ul>
<li>Then we will make the project</li>
</ul>
<pre><code>cd ~/catkin_ws
catkin_make
</code></pre>
<p>This will create two subfolders, <strong>build</strong> and <strong>devel</strong>. The <strong>build</strong> folder is none of our interest in most of the part. The <strong>devel</strong> folder contains a number of files and directories, the most interesting of which are the setup files. Running these configures your system to use this workspace, and the code that’s (going to be) contained inside it.
<br><br></p>
<ul>
<li>Configure your machine to use this Workspace</li>
</ul>
<pre><code>source devel/setup.bash
</code></pre>
<p>That's it, you've got your workspace up and running!</p>
<a class="header" href="print.html#ros-packages" id="ros-packages"><h1>ROS Packages</h1></a>
<p>ROS software is organized into packages, each of which contains some combination of code, data, and documentation. Usually there is a package for each 'function' of your robot. For example, you can have a package for navigation or for sensor capturing.
Thanks to the contributing community, there are many pre built packages available to download for free.</p>
<p>Let's create our first package!</p>
<ul>
<li>Creating a packages</li>
</ul>
<pre><code>cd ~/catkin_ws/src
catkin_create_pkg my_awesome_code rospy
</code></pre>
<p>This creates a new package named <strong>my_awesome_code</strong>. Inside that folder we'll find a <strong>/src</strong> directory where we will put our python code.</p>
<a class="header" href="print.html#complementary-info" id="complementary-info"><h2>Complementary info</h2></a>
<a class="header" href="print.html#roscore" id="roscore"><h3>roscore</h3></a>
<p>The <code>roscore</code> command is a service that provides connection information to nodes so that they can transmit messages to one another. <strong>It is necessary to run this command before launching any package</strong>.</p>
<a class="header" href="print.html#rosrun" id="rosrun"><h3>rosrun</h3></a>
<p>To run a package, we use the <code>rosrun</code> command executed like this:</p>
<pre><code>rosrun PACKAGE EXECUTABLE [ARGS]
</code></pre>
<p><strong>PACKAGE</strong> is the name of the created package, for example <strong>my_awesome_code</strong>, and <strong>EXECUTABLE</strong> is the name of the python file containing the code. <strong>Attention!</strong> The python file needs to be executable, juste use <code>sudo chmod +x file.py</code></p>
<a class="header" href="print.html#publisher-node" id="publisher-node"><h1>Publisher Node</h1></a>
<p>As shortly mentioned in the basic concept part, ROS allows interaction pulisher nodes and subscriber nodes.
In this chapter we'll create our first publisher node, which will send a basic message.</p>
<p>Make sure your current path is the previously created package.</p>
<a class="header" href="print.html#create-a-python-file" id="create-a-python-file"><h3>Create a python file</h3></a>
<pre><code>touch talker.py
</code></pre>
<a class="header" href="print.html#make-it-executable" id="make-it-executable"><h3>Make it executable</h3></a>
<pre><code>sudo chmod +x talker.py
</code></pre>
<a class="header" href="print.html#add-the-following-code" id="add-the-following-code"><h3>Add the following code</h3></a>
<pre><code class="language-python">import rospy
from std_msgs.msg import String

def talker():
    pub = rospy.Publisher('chatter', String, queue_size=10)
    rospy.init_node('talker', anonymous=True)
    rate = rospy.Rate(10) # 10hz
    while not rospy.is_shutdown():
        hello_str = &quot;hello world %s&quot; % rospy.get_time()
        rospy.loginfo(hello_str)
        pub.publish(hello_str)
        rate.sleep()

if __name__ == '__main__':
    try:
        talker()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<p>First we create the publisher node with reference 'chatter' and initialize it.</p>
<p>Then we go through a loop and create a 'hello world' string that we will publish on this 'talker' node.</p>
<p><code>rospy.loginfo()</code> is used to debug info to the user but doesn't interact with the node itself.</p>
<p>We could now run <code>roscore</code> and <code>rosrun my_awesome_code talker</code> in the console and see the debugger info but we don't have anybody subscribed(listening) to that <code>talker</code> node yet.</p>
<a class="header" href="print.html#subscriber-node" id="subscriber-node"><h1>Subscriber Node</h1></a>
<p>In this chapter we'll create our first listener node, which will retrieve info from another publishing node.</p>
<p>Make sure your current path is the previously created package.</p>
<a class="header" href="print.html#create-a-python-file-1" id="create-a-python-file-1"><h3>Create a python file</h3></a>
<pre><code>touch listener.py
</code></pre>
<a class="header" href="print.html#make-it-executable-1" id="make-it-executable-1"><h3>Make it executable</h3></a>
<pre><code>sudo chmod +x listener.py
</code></pre>
<a class="header" href="print.html#add-the-following-code-1" id="add-the-following-code-1"><h3>Add the following code</h3></a>
<pre><code class="language-python">import rospy
from std_msgs.msg import String

def callback(data):
    rospy.loginfo(rospy.get_caller_id() + 'I heard %s', data.data)

def listener():

    # In ROS, nodes are uniquely named. If two nodes with the same
    # name are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.
    rospy.init_node('listener', anonymous=True)

    rospy.Subscriber('chatter', String, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

if __name__ == '__main__':
    listener()
</code></pre>
<p>First we initialize the <code>listener</code> node and then tell it to subscribe to the previously created <code>chatter</code> node.
Here we also need to mention what to do with any incoming data from the <code>chatter</code> node. In this case, this function is called <code>callback</code>.</p>
<p>Now anytime we get incoming data from the subscribed <code>chatter</code> node, the <code>callback</code> function will log the data.</p>
<p>Note here that we specify the type of the incoming data (String).</p>
<a class="header" href="print.html#test-if-everything-is-working" id="test-if-everything-is-working"><h3>Test if everything is working</h3></a>
<pre><code class="language-roscore">rosrun my_awesome_code talker
rosrun my_awesome_code listener

</code></pre>
<p>You should now be able to see the following output:</p>
<pre><code>[INFO] [WallTime: 1439848277.141546] /listener_14364_1439848276913 \ I heard hello world 1439848277.14
[INFO] [WallTime: 1439848277.241519] /listener_14364_1439848276913 \ I heard hello world 1439848277.24
[INFO] [WallTime: 1439848277.341668] /listener_14364_1439848276913 \ I heard hello world 1439848277.34
[INFO] [WallTime: 1439848277.441579] /listener_14364_1439848276913 \ I heard hello world 1439848277.44
</code></pre>
<a class="header" href="print.html#raspberry-led-blinking-example" id="raspberry-led-blinking-example"><h1>Raspberry led blinking example</h1></a>
<p>Let's now create a small project for the Raspberry Pi, that uses ROS to turn on or off a led connected to it's GPIO's.</p>
<p>For this, we'll need a publisher node that acts like the brain of our system. The calculation and decisions are done on this node. The subscriber node will intercept the message and depending it's value, it will turn the led on or off.</p>
<p>Create a python program and name it <strong>controller.py</strong>.</p>
<p>We'll create a node called <strong>controller</strong> and send the led value to the <strong>led_value</strong> topic. This value will be incremented every second.</p>
<pre><code class="language-python">import rospy
from std_msgs.msg import Int

count = 0

def talker():
    pub = rospy.Publisher('led_value', Int, queue_size=10)
    rospy.init_node('controller', anonymous=True)
    rate = rospy.Rate(1)
    while not rospy.is_shutdown():
        count += 1
        pub.publish(count)
        rate.sleep()

if __name__ == '__main__':
    try:
        talker()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<p>Create a python program and name it <strong>led1.py</strong>.
We'll create a node called <strong>led1</strong> and intercept the <strong>led_value</strong> topic. If it's value is even, it will turn the led on. If it's odd, the led is turned off.</p>
<pre><code class="language-python">import rospy
import RPi.GPIO as GPIO
from std_msgs.msg import Int

count = 0

def callback(data):
    if data.data % 2:
      GPIO.output(18,GPIO.HIGH)
    else:
      GPIO.output(18,GPIO.LOW)

def listener():
    rospy.init_node('led1', anonymous=True)
    rospy.Subscriber('led_value', Int, callback)
    rospy.spin()

if __name__ == '__main__':
    try:
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(18,GPIO.OUT)
        listener()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<a class="header" href="print.html#launch-files" id="launch-files"><h1>Launch files</h1></a>
<p>Launch files are very common in ROS to both users and developers. They provide a convenient way to start up multiple nodes and a master, as well as other initialization requirements such as setting parameters.</p>
<a class="header" href="print.html#roslaunch" id="roslaunch"><h2>Roslaunch</h2></a>
<p><code>roslaunch</code> is used to open launch files. This can be done by either specifying the package the launch files are contained in followed by the name of the launch file, or by specifying the file path to the launch file.</p>
<pre><code class="language-bash">roslaunch package_name launch_file arg1:=value arg2:=value
</code></pre>
<blockquote>
<p>roslaunch will also start <code>roscore</code> if no master has been set. Pushing <code>Ctrl-C</code> in a terminal with a launch file running will close all nodes that were started with that launch files.</p>
</blockquote>
<a class="header" href="print.html#writing-a-launch-files" id="writing-a-launch-files"><h2>Writing a .launch files</h2></a>
<p>Launch files are of the format .launch and use a specific XML format. They can be placed anywhere within a package directory, but it is common to make a directory named <strong>Launch</strong> inside the workspace directory to organize all your launch files. The contents of a launch file must be contained between a pair of launch tags</p>
<pre><code class="language-xml">&lt;launch&gt;&lt;!-- Content here --&gt;&lt;/launch&gt;
</code></pre>
<p>To actually start a node, the <code>&lt;node&gt;</code> tags are used, the <strong>pkg</strong>, <strong>type</strong> and <strong>name</strong> argument are required.</p>
<pre><code class="language-xml">&lt;node pkg=&quot;...&quot; type=&quot;...&quot; name=&quot;...&quot; respawn=true/&gt;
</code></pre>
<ul>
<li>
<p><code>pkg, type and name</code>: The argument <strong>pkg</strong> points to the package associated with the node that is to be launched, while <strong>type</strong> refers to the name of the node executable file.</p>
</li>
<li>
<p><code>respawn or required</code>: However optional, it’s common to either have a respawn argument or a required argument, but not both. If <strong>respawn=true</strong>, then this particular node will be restarted if for some reason it closed. <strong>required=true</strong> will do the opposite, that is, it will shut down all the nodes associated with a launch file if this particular node comes down. There are other optional argument available on the ROS wiki.</p>
</li>
<li>
<p><code>arg</code>: Sometimes it is necessary to use a local variable in launch files. This can be done using</p>
</li>
</ul>
<pre><code class="language-xml">&lt;arg name=&quot;...&quot; value=&quot;...&quot;&gt;
</code></pre>
<a class="header" href="print.html#parameter-server" id="parameter-server"><h1>Parameter server</h1></a>
<p>Configuration information in ROS is usually saved to the Parameter server. The Parameter sever is a collection of values that can be accessed upon request through the command prompt, nodes or launch files. Parameters are intended to be fairly static, globally available values such as integers, floats, strings or bool values.</p>
<a class="header" href="print.html#parameters" id="parameters"><h2>Parameters</h2></a>
<p>Parameters are named using the normal ROS naming convention. This means that ROS parameters have a hierarchy that matches the namespaces used for topics and nodes. This hierarchy is meant to protect parameter names from colliding.</p>
<pre><code>/motors/front/left: 5.0
/motors/front/right: 4.0
/motors/rear/left: 4.0
/motors/rear/right: 5.0
</code></pre>
<p>The parameter <code>/motors/front/left</code> has the value <code>5.0</code>. You can also get the value for <code>/motors/front</code>, which is the dictionary</p>
<pre><code>left: 5.0
right: 4.0
</code></pre>
<p>And you can also get the value for <code>/motors</code>, which has a dictionary of dictionaries representation of the parameter tree:</p>
<pre><code>front: { left: 5.0, right: 4.0 }
rear: { left: 4.0, right: 5.0 }
</code></pre>
<a class="header" href="print.html#parameters-from-the-terminal" id="parameters-from-the-terminal"><h2>Parameters from the terminal</h2></a>
<p>ROS has a tool called <code>rosparam</code> to manage Parameter Server. The accepted parameters are as follows:</p>
<ul>
<li><code>rosparam set parameter value</code>: This sets the parameter</li>
<li><code>rosparam get parameter</code>: This gets the parameter</li>
<li><code>rosparam load file</code>: This loads parameters from the file</li>
<li><code>rosparam dump file</code>: This dumps parameters to the file</li>
<li><code>rosparam delete parameter</code>: This deletes the parameter</li>
<li><code>rosparam list</code>: This lists the parameter names</li>
</ul>
<p>For example, we can see the parameters in the server that are used by all nodes:</p>
<pre><code class="language-bash">rosparam list
</code></pre>
<p>We obtain the following output for the above example:</p>
<pre><code class="language-bash">/motors/front/left
/motors/front/right
/motors/rear/left
/motors/rear/right
</code></pre>
<p>If you want to read a value, you will use the <code>get</code> parameter:</p>
<pre><code>rosparam get /motors/front/left
</code></pre>
<p>To set a new value, you will use the <code>set</code> parameter:</p>
<pre><code>rosparam set /motors/front/left 6.0
</code></pre>
<a class="header" href="print.html#accessing-parameters-from-nodes" id="accessing-parameters-from-nodes"><h2>Accessing parameters from nodes</h2></a>
<p>It is often the case that your nodes will have to access the parameter server during start up to retrieve configuration information, or set a parameter value. This can be done quite easily in Python, to set a parameter use:</p>
<pre><code class="language-python">rospy.set_param(/motors/front/left, 6.0)
rospy.get_param(/motors/front/left)
</code></pre>
<a class="header" href="print.html#accessing-parameters-from-launchfiles" id="accessing-parameters-from-launchfiles"><h2>Accessing parameters from launchfiles</h2></a>
<p>The final source where you may need to access the parameter server is from a launch file. Setting a parameter value during a launch file is common practice to conveniently initialize parameters on start up. This can be done in your launch file using</p>
<pre><code class="language-yaml">&lt;param name=&quot;/motors/front/left&quot; value=&quot;6.0&quot;/&gt;
</code></pre>
<a class="header" href="print.html#parameters-files" id="parameters-files"><h2>Parameters files</h2></a>
<p>We can also create a file containing all the parameters of the project. The file is a yaml file.</p>
<pre><code class="language-yaml">start:
    cortex:
        green:
            position:
                x: 0.1
                y: -0.50
                orientation: 0
        red:
            position:
                x: 2.90
                y: -0.50
                orientation: 0
    minus:
        green:
            position:
                x: 0.5
                y: -0.85
                orientation: 0.0
        red:
            position:
                x: 2.3
                y: -0.9
                orientation: 3.14159
</code></pre>
<p>The parameters will be accessible via a dictionary in python.</p>
<a class="header" href="print.html#ros-good-practices-to-code-with-ros" id="ros-good-practices-to-code-with-ros"><h1>ROS: good practices to code with ROS</h1></a>
<p>In this tutorial, you will learn the good paractices to code with the Robot Operating System (ROS).</p>
<p>We never learn better than an example.</p>
<a class="header" href="print.html#example-of-the-start-test" id="example-of-the-start-test"><h2>Example of the start test</h2></a>
<ol>
<li>To include the developement environment (python in this example).</li>
</ol>
<pre><code class="language-python">#!/usr/bin/env python
</code></pre>
<ol start="2">
<li>To import all the librairies.</li>
</ol>
<pre><code class="language-python">import RPi.GPIO as GPIO
import rospy
from geometry_msgs.msg import Point
from std_msgs.msg import Bool, Empty
</code></pre>
<ol start="3">
<li>To set the global variables.</li>
</ol>
<pre><code class="language-python">left = 0
start = 0
step = 1
</code></pre>
<ol start="4">
<li>To do the basic setup.</li>
</ol>
<pre><code class="language-python">GPIO.setwarnings(False) # Ignore warning
GPIO.setmode(GPIO.BOARD) # Use physical pin numbering

pins = [38, 37] # The used pin(s)
#button0 - side - 38
#button1 - start - 37

for pin in pins:
    GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_DOWN) # Set pins to be an input pin and set initial value to be pulled low (off)
</code></pre>
<ol start="5">
<li>To define the ROS publishers.</li>
</ol>
<pre><code class="language-python">bob_pub = rospy.Publisher('show_bob', Empty, queue_size=10)
nav_pub = rospy.Publisher('required_coords', Point, queue_size=10)
</code></pre>
<ol start="6">
<li>To definition the functions.</li>
</ol>
<pre><code class="language-python">def show_bob():
    global bob_pub
    bob_pub.publish(Empty())



def is_left():
    global left
    global step
    if GPIO.input(pins[0]) == GPIO.LOW:
        left = 1
    else:
        left = 0
    if step == 1:
        show_bob()



def is_started():
    global start
    if GPIO.input(pins[1]) == GPIO.LOW:
        start = 1
    else:
        start = 0



def go_to(x, y):
    global nav_pub
    nav_pub.publish(Point(x, y, 0))



def step_ok_callback(data):
    if data.data == True:
        global step
        global left
        if step == 1:
            if left == 1:
                go_to(0, -30) # x and y: the coordinates of the left dispenser (1)
            else:
                go_to(0, 30) # x and y: the coordinates of the right dispenser (1)

        if step == 2:
            rospy.loginfo(&quot;Finished !&quot;)

        if step &gt; 2:
            rospy.loginfo(&quot;Anormally finished !&quot;)
        step += 1

    else:
        rospy.loginfo(&quot;Waiting ...&quot;)
</code></pre>
<ol start="7">
<li>To write the main code.</li>
</ol>
<pre><code class="language-python">if __name__ == '__main__':
    try:
        rospy.init_node(&quot;raspberry&quot;, anonymous=True)
        rospy.Subscriber('curry_arrived', Bool, step_ok_callback)
        rate=rospy.Rate(1)

        while not rospy.is_shutdown():
            is_started()
            if start == 1:
                is_left()
            rospy.loginfo(step)
            rate.sleep()

            else:
                print('Not started')

    except rospy.ROSInterruptException:
        pass
</code></pre>
<a class="header" href="print.html#explainations-of-the-code" id="explainations-of-the-code"><h2>Explainations of the code</h2></a>
<p>We always check if the start cable is off (if the robot can start).</p>
<p>When it is OK, we check the position of the side button (left or right of the game area) and publish a toggle message on <em>show_bob</em> topic to set the suction cup.</p>
<p>After this move, the first arduino send &quot;True&quot; to the <em>curry_arrived</em> topic and the callback function is launched. An instruction will be sent after each True message recieved on the same topic.</p>
<a class="header" href="print.html#ros-and-arduino" id="ros-and-arduino"><h1>ROS and Arduino</h1></a>
<a class="header" href="print.html#what-is-rosserial-" id="what-is-rosserial-"><h2>What is rosserial ?</h2></a>
<p>« Rosserial is a protocol for wrapping standard ROS serialized messages and multiplexing multiple topics and services over a character device such as a serial port or network socket.<br />
Rosserial provides a ROS communication protocol that works over your Arduino's UART. It allows your Arduino to be a full fledged ROS node which can directly publish and subscribe to ROS messages, publish TF transforms, and get the ROS system time.<br />
The rosserial protocol is aimed at point-to-point ROS communications over a serial transmission line. We use the same serialization/de-serialization as standard ROS messages, simply adding a packet header and tail which allows multiple topics to share a common serial link. »</p>
<p>These explanations come from the following websites :<br />
http://wiki.ros.org/rosserial<br />
http://wiki.ros.org/rosserial_arduino/Tutorials/Arduino%20IDE%20Setup</p>
<p>Now you know what rosserial is used for, but before testing you have to install some packages.</p>
<a class="header" href="print.html#rosserial-installation" id="rosserial-installation"><h2>Rosserial installation</h2></a>
<p>To install and use rosserial you have to run the terminal, first update apt-get which allows you to install packages :</p>
<pre><code>sudo apt-get update
</code></pre>
<p>You can choose to install the packages one by one :</p>
<p>First type :</p>
<pre><code>sudo apt-get install arduino
</code></pre>
<p>Then after the first installation :</p>
<pre><code>sudo apt-get install ros-kinetic-rosserial
</code></pre>
<p>And then :</p>
<pre><code>sudo apt-get install ros-kinetic-rosserial-arduino
</code></pre>
<p>Or you can directly install all the packages with one command in the terminal :</p>
<pre><code>sudo apt-get install -y \
                arduino \
                ros-kinetic-rosserial-arduino \
                ros-kinetic-rosserial
</code></pre>
<p>For more information you can follow <a href="http://wiki.ros.org/rosserial_arduino/Tutorials/Arduino%20IDE%20Setup">installation of ros on arduino</a></p>
<a class="header" href="print.html#arduinosensor-ros-code" id="arduinosensor-ros-code"><h2>Arduino&amp;Sensor ROS code</h2></a>
<p>This tutorial explains the code to use and transfer sonar sensors information with ROS.</p>
<p>For the «Cortex» robot we used four sensors, one on each side so that’s what the final code presented at the end of this tutorial is based on.</p>
<p>Firstly, in this code we are going to include the same libraries as shown in the Arduino Publisher Tutorial so you can refer to that part for the explanations.
An additional useful library used for the sensors is the NewPing.h. So here are all the necessary libraries :</p>
<pre><code class="language-cpp">#include &lt;ros.h&gt;
#include &lt;sensor_msgs/Range.h&gt;
#include &lt;NewPing.h&gt;
</code></pre>
<p>NewPing library isn't included in the Ros installation so you have to install it separatly <a href="https://playground.arduino.cc/Code/NewPing/#Download">Installation of NewpPing librairy</a></p>
<p>Then you have to define the pins for each sensor. In this case, the ultrasound sensor has two pins (Trigger ans Echo). Here is an exemple with the sensor located on the right of the robot:</p>
<pre><code class="language-cpp">#define TRIGGER_PIN1  5
#define ECHO_PIN1    4   
</code></pre>
<p>You also have to specify the maximum distance at which you want the sensor to still be able to detect :</p>
<pre><code class="language-cpp">#define MAX_DISTANCE 300
</code></pre>
<p>Now as we are using the NewPing library you can simply create an ultrasound sensor object by doing this :</p>
<pre><code class="language-cpp">NewPing sonar1(TRIGGER_PINR, ECHO_PINR, MAX_DISTANCE);
</code></pre>
<p>where you specify the pins and the maximum distance defined previously.</p>
<p>Moreover as mentioned in the Arduino Publisher Tutorial you specify the type of the ultrasound message and the name you want to assign to it :</p>
<pre><code class="language-cpp">sensor_msgs::Range range_msg;
</code></pre>
<p>You also have to add the following line which has also been explained in the Arduino Publisher Tutorial :</p>
<pre><code class="language-cpp">ros::Publisher pub_range1(&quot;ultrasound_1&quot;, &amp;range_msg);
</code></pre>
<p>We then have to fill each sonar object with the initialisation information associated :</p>
<pre><code class="language-cpp">range_msg.radiation_type = sensor_msgs::Range::ULTRASOUND;
range_msg.header.frame_id =  &quot;ultrasound_right&quot;;
range_msg.field_of_view = 0.3665;  // fake
range_msg.min_range = 0.0;
range_msg.max_range = MAX_DISTANCE;
</code></pre>
<p>Now we can add parts to the void loop of the Arduino code. The most important and useful one specifies the distance to an obstacle :</p>
<pre><code class="language-cpp">range_msg.range = tmp/100;
</code></pre>
<p>We can then publish that information about the distance (you can again refer to the Arduino Publisher Tutorial for the publishing part) :</p>
<pre><code class="language-cpp">pub_range1.publish(&amp;range_msg);
</code></pre>
<p>Here is the whole code for four ultrasound sensors based on the one presented in this link :
<a href="https://www.youtube.com/watch?v=gm3e-51ohgQ">https://www.youtube.com/watch?v=gm3e-51ohgQ</a><br />
Moreover the code below is available in the Github repo of Ecam Eurobot : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/ultrasound/arduino/sonar.ino">https://github.com/Ecam-Eurobot/Eurobot-2018/blob/ultrasound/arduino/sonar.ino</a></p>
<p><strong>Code to upload on the Arduino before launching rosserial :</strong></p>
<pre><code class="language-cpp">#include &lt;ros.h&gt;
#include &lt;sensor_msgs/Range.h&gt;
#include &lt;NewPing.h&gt;

#define TRIGGER_PIN1  5   //sensor 1
#define ECHO_PIN1    4   


#define MAX_DISTANCE 300 // Maximum distance we want to ping  

NewPing sonar1(TRIGGER_PIN1, ECHO_PIN1, MAX_DISTANCE); // back us

ros::NodeHandle  nh;

sensor_msgs::Range range_msg;

ros::Publisher pub_range1(&quot;ultrasound_1&quot;, &amp;range_msg);

char frameid[] = &quot;base_link&quot;;

long duration;
 float tmp;

void setup()
{
  nh.initNode();
  nh.advertise(pub_range1);

  range_msg.radiation_type = sensor_msgs::Range::ULTRASOUND;
  range_msg.header.frame_id =  &quot;ultrasound_1&quot;;
  range_msg.field_of_view = 0.3665;  // fake
  range_msg.min_range = 0.0;
  range_msg.max_range = MAX_DISTANCE;

}

long range_time;

void loop()
{
  //publish the adc value every 50 milliseconds
  //since it takes that long for the sensor to stabilize
  if ( millis() &gt;= range_time ){
    tmp=sonar1.ping_cm();
    range_msg.range = tmp/100;
    range_msg.header.stamp = nh.now();
    pub_range1.publish(&amp;range_msg_rear);
    range_time =  millis() + 50;
  }
  nh.spinOnce();
}

</code></pre>
<a class="header" href="print.html#rosserial-sonar-simple-test" id="rosserial-sonar-simple-test"><h2>Rosserial sonar simple test</h2></a>
<p>To test if you receive the messages published by the Arduino on the Rasperry Pi you have to do the following :<br />
To test it you first have to upload the code you can find at the end of this tutorial (which you can also find on the Github repo of the Ecam Eurobot : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/ultrasound/arduino/sonar.ino">https://github.com/Ecam-Eurobot/Eurobot-2018/blob/ultrasound/arduino/sonar.ino</a>). If you need further information and explanations for this code, you can refer to the Sonar Sensor Tutorial in the Electronics part. You can also use that tutorial for the wiring of the sonar on your Arduino. Of course you have to choose the pin numbers so they correspond to the ones declared in the code previously mentionned or you can directly change in the code the pin numbers yourself.<br />
Then you have to connect the Arduino board to the Raspberry. To do so you can simply connect them with the serial Arduino cable to the Raspberry USB port as shown on the figure below.</p>
<p><img src="img/software/ros/arduino/rasp_arduino_connection.png" alt="img" /></p>
<p>Image reference :<br />
<a href="http://www.instructables.com/id/Raspberry-Pi-Arduino-Serial-Communication/">http://www.instructables.com/id/Raspberry-Pi-Arduino-Serial-Communication/</a></p>
<p>After that, you have to launch the terminal and execute the following commands :</p>
<p>on a first window you type :</p>
<pre><code>roscore
</code></pre>
<p>on another window :</p>
<pre><code>rosrun rosserial_python serial_node.py /dev/ttyUSB0
</code></pre>
<p>/dev/ttyUSB0 is the usb port the Arduino is connected to so you’ll have to change the «USB0». You can find the name of the port tty* in the Arduino IDE or you can find it in the terminal by typing :</p>
<pre><code>ls /dev/tty*
</code></pre>
<p>when you plug the Arduino in the Raspberry port, you can execute this previous command to see which port has been added and thus know which one is the Arduino board.</p>
<p>Finally you can see what the Arduino is publishing on the topic of one of the ultrasound sensors, for example we will try here with the right ultrasound. You can see it by typing on another terminal window :</p>
<pre><code>rostopic echo /ultrasound_right
</code></pre>
<a class="header" href="print.html#publisher" id="publisher"><h1>Publisher</h1></a>
<p>To use ROS in an Arduino script you first have to include some libraries :</p>
<pre><code class="language-cpp">#include &lt;ros.h&gt;
#include &lt;std_msgs/Type.h&gt;
</code></pre>
<p>You have to replace «Type» with the type of the std message you are using. Here are the different types of std_msgs : <a href="http://wiki.ros.org/std_msgs">http://wiki.ros.org/std_msgs</a>.</p>
<p>You can also use different kind of messages. For instance the ultrasound sensors use :</p>
<pre><code class="language-cpp">#include &lt;sensor_msgs/Range.h&gt;
</code></pre>
<p>Then you have to start a ROS node (takes care of serial port communications, allows to create publishers and subscribers) with this line :</p>
<pre><code class="language-cpp">ros::NodeHandle nh;
</code></pre>
<p>You can now create a message object that you will later fill with data and this is the message you will finally publish :</p>
<pre><code class="language-cpp">std_msgs::String msg;
</code></pre>
<p>where msg is the name of the object. And of course you can choose the type of the message depending on the type of the transferred message.</p>
<p>Then you have to choose if you want to create a publisher, a subscriber or even both.</p>
<p>To create a publisher :</p>
<pre><code class="language-cpp">ros::Publisher chatter(&quot;chatter&quot;, &amp;msg);
</code></pre>
<p>This tells that we are going to be publishing a message of the type of the msg variable (with std_msgs::String type) on the topic «chatter». This lets the master tell any nodes listening on «chatter» that we are going to publish data on that topic.</p>
<p>You can now add lines in the void setup() of the Arduino script. You first initialize the node :</p>
<pre><code class="language-cpp">nh.initNode()
</code></pre>
<p>Next, the following call connects to the master to publicize that the node will be publishing messages on the given topic :</p>
<pre><code class="language-cpp">nh.advertise(chatter);
</code></pre>
<p>So finally this is what the void setup() in your Arduino code should look like :</p>
<pre><code class="language-cpp">void setup()
{
   nh.initNode();
   nh.advertise(chatter);
}
</code></pre>
<p>To fill the message object with the data you just have to do this :</p>
<pre><code class="language-cpp">msg.data = hello;
</code></pre>
<p>where hello is the data you put in your message and hello must have the same type as the msg variable.</p>
<p>You can then publish you message on the topic. To do so you can either publish it once or continually in the void loop() of your Arduino code like this :</p>
<pre><code class="language-cpp">
void loop()
{
   chatter.publish( &amp;str_msg );
}
</code></pre>
<p>Finally you have to add a last line of code in the loop that will call all the callbacks waiting to be called at that point in time :</p>
<pre><code class="language-cpp">nh.spinOnce();
</code></pre>
<p>Now that you know how each part of the code works you can test a «Hello World» example available on the wiki.ros.org website <a href="http://wiki.ros.org/rosserial_arduino/Tutorials/Hello%20World">http://wiki.ros.org/rosserial_arduino/Tutorials/Hello%20World</a> :</p>
<pre><code class="language-cpp">/*
 * rosserial Publisher Example
 * Prints &quot;hello world!&quot;
 */
// Use the following line if you have a Leonardo or MKR1000 
//#define USE_USBCON 

#include &lt;ros.h&gt;
#include &lt;std_msgs/String.h&gt;

ros::NodeHandle nh;

std_msgs::String str_msg;
ros::Publisher chatter(&quot;chatter&quot;, &amp;str_msg);

char hello[13] = &quot;hello world!&quot;;

void setup()
{
  nh.initNode();
  nh.advertise(chatter);
}

void loop()
{
  str_msg.data = hello;
  chatter.publish( &amp;str_msg );
  nh.spinOnce();
  delay(1000);
}
</code></pre>
<p>You have to upload this code on the Arduino board before connecting it to the Raspberry and before starting the test on ROS.</p>
<a class="header" href="print.html#test-on-a-raspberry" id="test-on-a-raspberry"><h1>Test on a Raspberry</h1></a>
<p>To test it you first have to connect the Arduino board to the Raspberry. Then you launch the terminal and execute the following commands :</p>
<p>on a first window you type :</p>
<pre><code>roscore
</code></pre>
<p>on another window :</p>
<p>/dev/ttyXXXX is the usb port the Arduino is connected to and you’ll have to find the exact name in order to replace the XXXX by the name of the port (examples : ttyUSB0, ttyACM0, ttyACM1, ...). You can find the name of the port ttyXXXX in the Arduino IDE or you can find it in the terminal by typing :</p>
<pre><code>ls /dev/tty*
</code></pre>
<p>you should first execute this previous command and only then plug the Arduino in the Raspberry usb port and execute this command again to see which port has been added to the list displayed on the terminal and thus know which one is the Arduino board.</p>
<p>The first time you use the usb port the Arduino is connected to, you have to give permissions to use that port. To do so, you have to type :</p>
<pre><code>sudo chmod 666 /dev/ttyXXXX
</code></pre>
<p>Now that you know the port you are using and you have permissions, you can type this :</p>
<pre><code>rosrun rosserial_python serial_node.py /dev/ttyXXXX
</code></pre>
<p>Finally you can see what the Arduino is publishing on a specific topic by typing on another terminal window :</p>
<pre><code>rostopic echo /topic_name
</code></pre>
<p>where you have to replace topic_name by the topic your Arduino is publishing on. In the example above, the «hello world!» is published on the topic «chatter». So you can type :</p>
<pre><code>rostopic echo /chatter
</code></pre>
<a class="header" href="print.html#subscriber" id="subscriber"><h1>Subscriber</h1></a>
<p>To try this tutorial on you Arduino board you have to connect a Led. The pin used here is the 13 but of course you can change it in the code if you want to use another one.</p>
<p>As in the Arduino Publisher Tutorial you first have to include the libraries. One of them depends on the message you are transferring with ROS. In the following example we will choose an empty message. This means that the message doesn’t contain anything. So when the subscriber receives the message, it doesn’t react depending on its content but it only reacts because a message has been sent. As the type of the std_msg is «Empty», you have to include the following lines at the beginning of your Arduino code :</p>
<pre><code class="language-cpp">#include &lt;ros.h&gt;
#include &lt;std_msgs/Empty.h&gt;
</code></pre>
<p>Here again, like the Arduino Publisher Tutorial code, you have to start a ROS node with this line :</p>
<pre><code class="language-cpp">ros::NodeHandle nh;
</code></pre>
<p>Then you initiate the callback function where you have to specify the name of the callback (messageCb), the type of the message (std_msgs::Empty) and the name of the message (toggle_msg which contains the transferred message). The callback is the function called each time you receive a message. If toggle_msg had a content you could use it in the callback but it is not the case here as the message is of type «Empty».</p>
<pre><code class="language-cpp">void messageCb( const std_msgs::Empty&amp; toggle_msg){
  digitalWrite(13, HIGH-digitalRead(13));   // blink the led
}
</code></pre>
<p>The following line of code is used to instantiate the subscriber. To do so you have to specify two arguments : the topic name (we chose in this example : «toggle_led») and the callback function we defined previously (messageCb).</p>
<pre><code class="language-cpp">ros::Subscriber&lt;std_msgs::Empty&gt; sub(&quot;toggle_led&quot;, &amp;messageCb );
</code></pre>
<p>As this is a blink led example, in the setup part of your Arduino code you first have to use the number 13 pin as an output.</p>
<pre><code class="language-cpp">pinMode(13, OUTPUT);
</code></pre>
<p>Then for the ROS part of the setup you have to first initialize the node :</p>
<pre><code class="language-cpp">nh.initNode();
</code></pre>
<p>And subscribe to the node you want to :</p>
<pre><code class="language-cpp">nh.subscribe(sub);
</code></pre>
<p>So finally this is what the void setup() in your Arduino code should look like :</p>
<pre><code class="language-cpp">void setup()
{
  pinMode(13, OUTPUT);
  nh.initNode();
  nh.subscribe(sub);
}
</code></pre>
<p>Finally you just have to add in the void loop of your Arduino code the following lines where the spinOnce passes arguments to the callback :</p>
<pre><code class="language-cpp">void loop()
{
  nh.spinOnce();
  delay(1);
}
</code></pre>
<p>Now that you know how each part of the code works you can test the blink led example available on the wiki.ros.org website <a href="http://wiki.ros.org/rosserial_arduino/Tutorials/Blink">http://wiki.ros.org/rosserial_arduino/Tutorials/Blink</a> :</p>
<pre><code class="language-cpp">/*
 * rosserial Subscriber Example
 * Blinks an LED on callback
 */
#include &lt;ros.h&gt;
#include &lt;std_msgs/Empty.h&gt;

ros::NodeHandle nh;

void messageCb( const std_msgs::Empty&amp; toggle_msg){
  digitalWrite(13, HIGH-digitalRead(13));   // blink the led
}

ros::Subscriber&lt;std_msgs::Empty&gt; sub(&quot;toggle_led&quot;, &amp;messageCb );

void setup()
{
  pinMode(13, OUTPUT);
  nh.initNode();
  nh.subscribe(sub);
}

void loop()
{
  nh.spinOnce();
  delay(1);
}
</code></pre>
<p>You have to upload this code on the Arduino board before connecting it to the Raspberry and before starting the test on ROS.</p>
<a class="header" href="print.html#test-on-a-raspberry-1" id="test-on-a-raspberry-1"><h1>Test on a Raspberry</h1></a>
<p>To test it you first have to connect the Arduino board to the Raspberry. Then you launch the terminal and execute the following commands :</p>
<p>on a first window you type :</p>
<pre><code>roscore
</code></pre>
<p>on another window :</p>
<p>/dev/ttyXXXX is the usb port the Arduino is connected to and you’ll have to find the exact name in order to replace the XXXX by the name of the port (examples : ttyUSB0, ttyACM0, ttyACM1, ...). You can find the name of the port ttyXXXX in the Arduino IDE or you can find it in the terminal by typing :</p>
<pre><code>ls /dev/tty*
</code></pre>
<p>you should first execute this previous command and only then plug the Arduino in the Raspberry usb port and execute this command again to see which port has been added to the list displayed on the terminal and thus know which one is the Arduino board.</p>
<p>The first time you use the usb port the Arduino is connected to, you have to give permissions to use that port. To do so, you have to type :</p>
<pre><code>sudo chmod 666 /dev/ttyXXXX
</code></pre>
<p>Now that you know the port you are using and you have permissions, you can type this :</p>
<pre><code>rosrun rosserial_python serial_node.py /dev/ttyXXXX
</code></pre>
<p>Finally, in order to send a single message to the Arduino, you can publish on a specific topic by typing on another terminal window :</p>
<pre><code>rostopic pub toggle_led std_msgs/Empty --once
</code></pre>
<p>where toggle_led is the topic you are publishing on, std_msgs/Empty is the type of the message and we use «—once» to publish this message only once.</p>
<a class="header" href="print.html#advanced-concepts" id="advanced-concepts"><h1>Advanced concepts</h1></a>
<a class="header" href="print.html#custom-messages" id="custom-messages"><h1>Custom messages</h1></a>
<a class="header" href="print.html#robot-model" id="robot-model"><h1>Robot model</h1></a>
<a class="header" href="print.html#visualization-using-rviz" id="visualization-using-rviz"><h1>Visualization using RVIZ</h1></a>
<a class="header" href="print.html#useful-packages" id="useful-packages"><h1>Useful packages</h1></a>
<a class="header" href="print.html#map-server" id="map-server"><h1>Map Server</h1></a>
<a class="header" href="print.html#navigation-stack" id="navigation-stack"><h1>Navigation stack</h1></a>
<a class="header" href="print.html#mecanum-wheels-1" id="mecanum-wheels-1"><h1>Mecanum wheels</h1></a>
<p>We introduced the <a href="mechanical/mecanum.html">mecanum wheels</a> in the mechanical part.
In this chapter we will review a ROS node we made to control the mecanum wheels.</p>
<a class="header" href="print.html#ros-twist" id="ros-twist"><h1>ROS Twist</h1></a>
<p>In the ROS navigations stack, all movements are indicated by <a href="http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html">Twist</a> messages.
These messages contain linear and angular velocity components and are often used to express the global movement of the base.</p>
<p>To control the 4 motors, we need to convert those velocities in angular velocities for each wheel. In our ROS node, we can define the
following function:</p>
<pre><code class="language-python">def convert(move):
    x = move.linear.x
    y = move.linear.y
    rot = move.angular.z

    front_left = (x - y - rot * WHEEL_GEOMETRY) / WHEEL_RADIUS
    front_right = (x + y + rot * WHEEL_GEOMETRY) / WHEEL_RADIUS
    back_left = (x + y - rot * WHEEL_GEOMETRY) / WHEEL_RADIUS
    back_right = (x - y + rot * WHEEL_GEOMETRY) / WHEEL_RADIUS
</code></pre>
<p>We used the inverse kinematic equations presented in the <a href="mechanical/mecanum.html">mecanum wheels</a> chapter to convert global base velocity
into individual angular velocities.</p>
<a class="header" href="print.html#ros-node" id="ros-node"><h2>ROS node</h2></a>
<p>Now that we have a function to transform the twist message, let's setup the node to subscribe to Twist messages and publish individual
angular velocity messages to specific topics:</p>
<pre><code class="language-python">rospy.init_node('mecanum')

# Get parameters about the geometry of the wheels
WHEEL_SEPARATION_WIDTH = rospy.get_param(&quot;/wheel/separation/horizontal&quot;)
WHEEL_SEPARATION_LENGTH = rospy.get_param(&quot;/wheel/separation/vertical&quot;)
WHEEL_GEOMETRY = (WHEEL_SEPARATION_WIDTH + WHEEL_SEPARATION_LENGTH) / 2
WHEEL_RADIUS = rospy.get_param(&quot;/wheel/diameter&quot;) / 2


pub_mfl = rospy.Publisher('motor/front/left', Float32, queue_size=1)
pub_mfr = rospy.Publisher('motor/front/right', Float32, queue_size=1)
pub_mbl = rospy.Publisher('motor/rear/left', Float32, queue_size=1)
pub_mbr = rospy.Publisher('motor/rear/right', Float32, queue_size=1)

sub = rospy.Subscriber('cmd_vel', Twist, convert)
rospy.spin()
</code></pre>
<p>In this extract, we initialize the node, get some parameters from ROS' parameter server, define a publisher for each mecanum wheel and
subscribe to the <code>cmd_vel</code> topic where Twist messages are send to. In the subscription, we provide our convertion function as a callback.
This means that whenever a twist message is published on the topic, our function will be called with the twist message as argument.</p>
<p>The only thing left to do is to adapt our function to pusblish the correct values to the corresponding topics.</p>
<p>The code can be found in the Eurobot-2018 repository in the <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/ros_packages/mecanum/src/mecanum.py">mecanum package</a></p>
<a class="header" href="print.html#color-detection" id="color-detection"><h1>Color detection</h1></a>
<blockquote>
<p>The objective of this module is to detect a color combination and send it to the “Minus” robot module whose function is to build a tower made of cubes.</p>
</blockquote>
<a class="header" href="print.html#getting-started-2" id="getting-started-2"><h2>Getting started</h2></a>
<a class="header" href="print.html#image-treatment-module" id="image-treatment-module"><h3>Image treatment module</h3></a>
<a class="header" href="print.html#summary" id="summary"><h4>Summary</h4></a>
<p>First and foremost, we must connect to GoPro wifi to take a picture of the color combination. Here, we have chosen a GoPro as a camera because it has an acceptable quality (780 pixel-HD) and it has also a Wi-Fi module for the remote control.</p>
<p>Once the photo has been taken, the camera automatically switches off and we connect to the robot by wifi (a Raspberry connected with the same Wi-Fi for future image treatment).</p>
<p>During this treatment, we use the OpenCV free graphics library.</p>
<p>We have drawn three frames on the picture (one for each cube to detect) to delimit the test portion. The board analyzes all pixels within each frame to obtain the color.</p>
<p>However, we have implemented in our program the different possible combinations to save time. Indeed, we only required two colors to deduce the final combination.</p>
<p>As a matter of conclusion, we send combination to the robot by ROS.</p>
<p><img src="img/software/image-processing/image1.png" alt="z" /></p>
<a class="header" href="print.html#bill-of-materials" id="bill-of-materials"><h4>Bill of materials:</h4></a>
<ul>
<li>One Raspberry Pi zero W</li>
<li>One Wi-Fi GoPro (Hero+)</li>
<li>One 5V battery</li>
<li>Etcher (https://etcher.io/) to install an OS on the Raspberry</li>
</ul>
<a class="header" href="print.html#connections" id="connections"><h4>Connections</h4></a>
<ul>
<li>No pins required</li>
</ul>
<a class="header" href="print.html#setup" id="setup"><h4>Setup</h4></a>
<ul>
<li>Download last version Ubuntu mate (16.04) or an another distribution for the raspberry (see <a href="ros/install.md">install</a>)</li>
<li>Active WiFi and open terminal (<strong><em>alt+ctrl+t</em></strong>):
<ol>
<li>
<p>Install ROS (see <a href="ros/install.md">install</a>)</p>
</li>
<li>
<p>Download this repo from <a href="https://github.com/Ecam-Eurobot/Tutorials/archive/master.zip">github</a>, unzip Tutorials-master.zip to open the main folder.</p>
</li>
<li>
<p>Drag the folder in the terminal, you'll see a url. Then run this command :</p>
<pre><code>cd &quot;url&quot;
</code></pre>
</li>
<li>
<p>Run this code above to go to &quot;codes&quot; folder:</p>
<pre><code>cd src/codes/software/image-processing/tests
</code></pre>
</li>
<li>
<p>Connect the GoPro (WiFi) or your webcam (USB port) to the Raspberry</p>
</li>
</ol>
</li>
</ul>
<a class="header" href="print.html#checking-camera" id="checking-camera"><h3>Checking camera</h3></a>
<p>Check your camera is working. Type the following command line into your prompt and press enter :</p>
<ol>
<li>Go to &quot;test camera&quot; folder :</li>
</ol>
<pre><code>cd src/codes/software/image-processing/tests/test_camera
</code></pre>
<p><strong>Checking GoPro</strong></p>
<p>We use a library called &quot;goprocam&quot; that contains all functions to control GoPro</p>
<ul>
<li>
<p>Run this command to test GoPro in your terminal</p>
<pre><code>python3 go_pro_test.py
</code></pre>
<p><strong><em>Make sure your Raspberry is on the same WiFi network as GoPro !</em></strong></p>
</li>
</ul>
<p>The code :</p>
<pre><code>#go_pro_test.py

from goprocam import GoProCamera
from goprocam import constants

# Connect to GoPro
gpCam = GoProCamera.GoPro()

# Take a photo and save it in the current folder 
gpCam.downloadLastMedia(gpCam.take_photo(0))
</code></pre>
<p><strong>Checking webcam</strong></p>
<p>If you don't have a GoPro, you can also use a webcam. Type the following command line into your prompt and press enter :</p>
<p>We use here &quot;OpenCV&quot; library to display and save images from the webcam</p>
<ul>
<li>
<p>Run this command to check the webcam</p>
<pre><code>python webcam_test.py
</code></pre>
</li>
</ul>
<p>The code :</p>
<pre><code># webcam_test.py

import cv2 

# Create an object called camera and connect the first camera to the computer
camera = cv2.VideoCapture(0)

# Take a photo and save it in the current folder 
return_value, image = camera.read()
cv2.imwrite('opencv'+'.png', image)
</code></pre>
<p><strong>Result</strong> :
<img src="img/software/image-processing/image5.png" alt="z" /></p>
<a class="header" href="print.html#scripts" id="scripts"><h2>Scripts</h2></a>
<p>After checking the camera, we must run a script to automate the color detection and the WiFi switching (if you use a GoPro).<br />
This script makes three actions :</p>
<ol>
<li>To switch WiFi to connect to GoPro to obtain a picture</li>
<li>To send the picture to the Raspberry to start the image processing</li>
<li>To give a color combination</li>
</ol>
<p>Type the following command line into your prompt and press enter to check the settings and run the script</p>
<ul>
<li>Go to color_detection folder :</li>
</ul>
<pre><code>cd ../test_color_detection
</code></pre>
<ul>
<li>Open GP_combination.sh :</li>
</ul>
<pre><code>nano GP_combination.sh 
</code></pre>
<ul>
<li>Change the name with your GoPro WiFi :</li>
</ul>
<pre><code>nmcli c up &quot;your GoPro wifi&quot;
</code></pre>
<ul>
<li>Change the name with your robot WiFi</li>
</ul>
<pre><code>nmcli c up &quot;your wifi robot&quot;  
</code></pre>
<p>save it (<strong><em>ctrl+x</em></strong>)</p>
<ul>
<li>Run this script on the terminal :</li>
</ul>
<pre><code>bash GP_combination.sh 
</code></pre>
<p>You'll see 3 colors frames on the picture and the final combination color on the terminal)
<img src="img/software/image-processing/image6.png" alt="z" /></p>
<p>The code :</p>
<pre><code>#GP_Combination.sh

#!/usr/bin/expect

#switch to &quot;GoPro wifi and connect to the GoPro&quot; 

nmcli c up &quot;armen&quot; 
sleep 10

#Take photo with GoPro
python3 GP_takePhoto.py

#Switch to &quot;robot wifi to connect to minus(robots)

nmcli c up &quot;Airport Express Lenaerts&quot; 

#To obtain the color combination 
python2 color_detection.py
</code></pre>
<p>If you prefer using the webcam instead of GoPro</p>
<pre><code>bash WB_combination.sh 
</code></pre>
<p>The code :</p>
<pre><code>#WB_combination.sh 

#!/usr/bin/expect

python2 WB_takePhoto.py

python2 color_detection.py
</code></pre>
<p><strong>Result</strong> :
The result is the same for GoPro and webcam.</p>
<p>You'll see 3 colors frames on the picture and the final combination color on the terminal as shown in the image below</p>
<p><img src="img/software/image-processing/image6.png" alt="z" /></p>
<a class="header" href="print.html#image-processing---color_detectionpy" id="image-processing---color_detectionpy"><h2>Image processing - color_detection.py</h2></a>
<p>After taking a picture with the camera or the GoPro, we must process it to generate the color combination :
The program creates three frames, one for each cube and analyzes all pixels within each frame:</p>
<ol>
<li>It looks whether the color detected is in the range color defined for every color (each color range is defined with one high and one low BGR value)</li>
<li>After that, it returns a value: more the value is great, more the color lies within the range. The program adds up the values and the final value thus obtained determines the color within the range of colors determined initially.</li>
</ol>
<p><strong>Adjusting the position of a frame</strong></p>
<p>We must adjust the position of frames to target the part of the image we want to process :<br />
Each position is represented by a matrice. The first value (pixel) is linked with red frame, the second value (pixel) with yellow frame and the last value (pixel) with white frame.</p>
<p><img src="img/software/image-processing/image2.png" alt="before" /></p>
<p><em>positionName = [red frame value, yellow frame value, white frame value]</em></p>
<p>Here is the different positions for each frame:</p>
<ul>
<li><strong>xmin</strong> is the left side of the frame</li>
<li><strong>xmax</strong> is the right side par of the frame</li>
<li><strong>ymin</strong> is the top side of the frame</li>
<li><strong>ymax</strong> is the bottom side of the frame</li>
</ul>
<p><strong>Procedure</strong> :</p>
<ol>
<li>Maintain your cursor where you want to place a side of the frame</li>
<li>Take note of the position (pixel)</li>
<li>Open a new tab (<strong><em>ctrl+shift+t</em></strong>) and run this command to change a side of a frame in the following code(color_detection.py) :</li>
</ol>
<pre><code>nano color_detection.py 
</code></pre>
<ol start="4">
<li>Restart for another side of the frame then save the file (<strong><em>ctrl+x</em></strong>)</li>
</ol>
<p><strong><em>Result</em></strong> :</p>
<p><img src="img/software/image-processing/image3.png" alt="after" /></p>
<p><strong>Adjusting the range color</strong></p>
<p>We must adjust the color range (RBG) to define each color. Therefore, the programme will be able to identify differents colors in each frame in function of these RGB values. We represente  each color range by a matrix :</p>
<p><em>color_range = [blue value, green value, red value]</em></p>
<p>As a reminder, an RGB color value is specified with RGB (red, green, blue).
Each parameter (red, green, and blue) defines the intensity of the color as an integer between 0 and 255.
For example, rgb(0, 0, 255) is rendered as blue, because the blue parameter is set to its highest value (255) and the others are set to 0.</p>
<p><strong>Procedure</strong> :</p>
<ol>
<li>Maintain your cursor in the center of the cube</li>
<li>Take note of the RGB color</li>
<li>Open a new tab (<strong><em>ctrl+shift+t</em></strong>) and change the color range in the code (color_detection.py)</li>
</ol>
<pre><code>nano color_detection.py 
</code></pre>
<ol start="4">
<li>Restart for another cube then save the file (<strong><em>ctrl+x</em></strong>)</li>
</ol>
<p><strong><em>Result</em></strong> :</p>
<p><img src="img/software/image-processing/image4.png" alt="z" /></p>
<p><strong>Automation</strong></p>
<p>We have also implemented in our program the different possible combinations to save time. Indeed, we only required two colors to deduce the final combination.</p>
<a class="header" href="print.html#application-with-ros" id="application-with-ros"><h2>Application with ROS</h2></a>
<p>You use <strong><em>ROS</em></strong> to send the color combination to another robot module :</p>
<ol>
<li>Create a package &quot;image-processing&quot; and create a launch files&quot; test.launch&quot; (more details <a href="ros/install.md">here</a>)</li>
<li>Drag the code &quot;image-analyze.py&quot;(codes/software/image-processing) to catkin_ws/src/&quot;image-processing&quot;</li>
<li>Open terminal and launch ROS :</li>
</ol>
<pre><code>. ~/eurobot_ws/devel/setup.bash
roslaunch image-processing test.launch 
</code></pre>
<ul>
<li>Open a new tab (<strong><em>ctrl+shift+t</em></strong>) to display messages published to a topic :</li>
</ul>
<pre><code>rostopic echo /color_seq 
</code></pre>
<p><img src="img/software/image-processing/image7.png" alt="z" /></p>
<p><strong><em>Don't forget to change frames positions and color ranges ! (see section below)</em></strong></p>
<a class="header" href="print.html#flashlight-module" id="flashlight-module"><h3>Flashlight module</h3></a>
<a class="header" href="print.html#aim" id="aim"><h4>Aim</h4></a>
<p>We added a LED flashlight above the camera because light is an important factor and can bias our previous calculations. Therefore, the constant level of light thus created enables us to maintain our settings. This flashlight is turned off immediately after the camera has taken the photo, so as not to disrupt other teams or distract the audience.</p>
<a class="header" href="print.html#bill-of-materials-1" id="bill-of-materials-1"><h4>Bill of materials:</h4></a>
<ul>
<li>One Raspberry Pi zero W</li>
<li>One LED flashlight</li>
<li>One 5V battery</li>
</ul>
<a class="header" href="print.html#connections-1" id="connections-1"><h4>Connections</h4></a>
<p>We use pin 4 of the raspberry Pi zero to power the gate pin of IRF520 mosfet in order to control the light. The board is powered with a 5V power supply from the battery (pin 2 = 5V and pin 6= GND).</p>
<a class="header" href="print.html#setup-1" id="setup-1"><h4>Setup</h4></a>
<ul>
<li>for testing the flashlight, run :</li>
</ul>
<pre><code>python flashlight.py
</code></pre>
<p>You'll blink the flashlight</p>
<a class="header" href="print.html#robots" id="robots"><h1>Robots</h1></a>
<a class="header" href="print.html#a2018-1" id="a2018-1"><h1>2018</h1></a>
<p>For the year 2018, the actions robots must perform to earn points are:</p>
<ul>
<li>collect blocks of colors to form a turn.</li>
<li>collect colored balls, sort them by color and send them to several destinations.</li>
<li>push a bee to explode an inflatable balloon.</li>
<li>press a button to turn on a screen.</li>
</ul>
<p>To do so, we decided to design 2 robots, Cortex and Minus.</p>
<p>Cortex is responsible for collecting the balls and pushing the bee and for Minus, collect the blocks and press a button.</p>
<p>In this chapter, we will talk about the general structure of the 2 robots and how to start them.</p>
<a class="header" href="print.html#folder-structure" id="folder-structure"><h1>Folder structure</h1></a>
<p>Here is the general structure of our project for Eurobot 2018.</p>
<pre><code class="language-bash">Eurobot-2018
│   README.md
│   LICENSE
│   .gitignore
└───arduino
│
└───documentation
|
└───ros_packages
|   └───differential-drive
│   |
|   └───differential_driver
│   |
|   └───ecam_msg
│   |
|   └───mecanum
│   |
|   └───navigation
│   |
|   └───robot_2018
│   |
|   └───robot_description
│   |
|   └───sensors
│   |
|   └───strategy
</code></pre>
<p>The different folders:</p>
<ul>
<li><strong>arduino</strong>: This folder contains all the arduino codes used within the 2 robots.</li>
<li><strong>documentation</strong>: The project documentation for the same year of Eurobot.</li>
<li><strong>ros_packages</strong>: Contains all our ros packages.
<ul>
<li><strong>differential-drive</strong>: Provides some basic tools for interfacing a differential-drive robot with the ROS navigation stack. The intention is to make this independent of specific robot implementation.</li>
<li><strong>differential_driver</strong>: package for the differential drive of Minus.</li>
<li><strong>ecam_msg</strong>: contains custom messages for robots.</li>
<li><strong>mecanum</strong>: package for the mechanic wheels of Cortex.</li>
<li><strong>robot_2018</strong>: package that manages the launch of 2 robots.</li>
<li><strong>robot_description</strong>: package that describes robots for simulation with rviz.</li>
<li><strong>sensors</strong>: packages for ultrasound management.</li>
<li><strong>strategy</strong>: package for the strategies chosen by the 2 robots.</li>
</ul>
</li>
</ul>
<blockquote>
<p>For more information about what is a <a href="software/ros/basics/packages.html">package</a> in ROS.</p>
</blockquote>
<a class="header" href="print.html#minus" id="minus"><h1>Minus</h1></a>
<a class="header" href="print.html#architecture" id="architecture"><h1>Architecture</h1></a>
<p><img src="img/robots/architecture.PNG" alt="Architecture" /></p>
<p>There is a raspberry master who talks to the arduinos via the serial port thanks to the <code>rosserial</code> library.</p>
<p>The arduinos who control the motors return the values of the encoders to the rapsberry and the raspberry returns them the speeds to apply.</p>
<p>An arduino takes care of the control of the elevator, the collection of the blocks and sends the values of the ultrasound sensors to the raspberry.</p>
<a class="header" href="print.html#packages" id="packages"><h1>Packages</h1></a>
<a class="header" href="print.html#differential-drive" id="differential-drive"><h2>Differential-drive</h2></a>
<p>Having no time to implement ourselves, a library to manage the differential navigation, we look for an existing library compatible with ROS.</p>
<p>This package provides some basic tools for interfacing a differential-drive robot with the ROS navigation stack.</p>
<p><img src="http://wiki.ros.org/differential_drive?action=AttachFile&amp;do=get&amp;target=differential_drive_overview.png" alt="Schema" /></p>
<p>The library therefore needed only 2 input information, the return of the encoders of the left wheel (<code>lwheel</code>) and right (<code>rwheel</code>).
At the exit, we received the speeds of the 2 wheels, <code>lmotor</code> and <code>rmotor</code>.</p>
<a class="header" href="print.html#setting-up-the-differential-drive-package-pid-controller" id="setting-up-the-differential-drive-package-pid-controller"><h4>Setting up the differential-drive package PID controller</h4></a>
<p>The configuration of the package is done via a launchfile containing all the necessary parameters such as <code>Kp</code>, <code>Ki</code>, <code>Kd</code>, etc.</p>
<p>This configuration is in the file
<code>ros_packages/differential_driver/launch/minus.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
  &lt;rosparam param=&quot;ticks_meter&quot;&gt;16400&lt;/rosparam&gt;	
  &lt;node pkg=&quot;differential_drive&quot; type=&quot;diff_tf.py&quot; name=&quot;diff_tf&quot;&gt;
      &lt;rosparam param=&quot;base_width&quot;&gt;0.353&lt;/rosparam&gt;
      &lt;rosparam param=&quot;encoder_min&quot;&gt;-1000000&lt;/rosparam&gt;
      &lt;rosparam param=&quot;encoder_max&quot;&gt;1000000&lt;/rosparam&gt;
  &lt;/node&gt;
  &lt;node pkg=&quot;differential_drive&quot; type=&quot;pid_velocity&quot; name=&quot;lpid_velocity&quot;&gt;
      &lt;remap from=&quot;wheel&quot; to=&quot;lwheel&quot;/&gt;
      &lt;remap from=&quot;motor_cmd&quot; to=&quot;lmotor_cmd&quot;/&gt;
      &lt;remap from=&quot;wheel_vtarget&quot; to=&quot;lwheel_vtarget&quot;/&gt;
      &lt;remap from=&quot;wheel_vel&quot; to=&quot;lwheel_vel&quot;/&gt;
      &lt;rosparam param=&quot;Kp&quot;&gt;25&lt;/rosparam&gt;
      &lt;rosparam param=&quot;Ki&quot;&gt;10&lt;/rosparam&gt;
      &lt;rosparam param=&quot;Kd&quot;&gt;0&lt;/rosparam&gt;
      &lt;rosparam param=&quot;out_min&quot;&gt;-254&lt;/rosparam&gt;
      &lt;rosparam param=&quot;out_max&quot;&gt;254&lt;/rosparam&gt;
      &lt;rosparam param=&quot;rate&quot;&gt;20&lt;/rosparam&gt;
      &lt;rosparam param=&quot;timeout_ticks&quot;&gt;10&lt;/rosparam&gt;
      &lt;rosparam param=&quot;rolling_pts&quot;&gt;5&lt;/rosparam&gt;
      &lt;rosparam param=&quot;encoder_min&quot;&gt;-1000000&lt;/rosparam&gt;
      &lt;rosparam param=&quot;encoder_max&quot;&gt;1000000&lt;/rosparam&gt;
  &lt;/node&gt;
  &lt;node pkg=&quot;differential_drive&quot; type=&quot;pid_velocity&quot; name=&quot;rpid_velocity&quot;&gt;
      &lt;remap from=&quot;wheel&quot; to=&quot;rwheel&quot;/&gt;
      &lt;remap from=&quot;motor_cmd&quot; to=&quot;rmotor_cmd&quot;/&gt;
      &lt;remap from=&quot;wheel_vtarget&quot; to=&quot;rwheel_vtarget&quot;/&gt;
      &lt;remap from=&quot;wheel_vel&quot; to=&quot;rwheel_vel&quot;/&gt;
      &lt;rosparam param=&quot;Kp&quot;&gt;25&lt;/rosparam&gt;
      &lt;rosparam param=&quot;Ki&quot;&gt;10&lt;/rosparam&gt;
      &lt;rosparam param=&quot;Kd&quot;&gt;0&lt;/rosparam&gt;
      &lt;rosparam param=&quot;out_min&quot;&gt;-254&lt;/rosparam&gt;
      &lt;rosparam param=&quot;out_max&quot;&gt;254&lt;/rosparam&gt;
      &lt;rosparam param=&quot;rate&quot;&gt;20&lt;/rosparam&gt;
      &lt;rosparam param=&quot;timeout_ticks&quot;&gt;10&lt;/rosparam&gt;
      &lt;rosparam param=&quot;rolling_pts&quot;&gt;5&lt;/rosparam&gt;
      &lt;rosparam param=&quot;encoder_min&quot;&gt;-1000000&lt;/rosparam&gt;
      &lt;rosparam param=&quot;encoder_max&quot;&gt;1000000&lt;/rosparam&gt;
  &lt;/node&gt;

  &lt;node pkg=&quot;differential_drive&quot; type=&quot;twist_to_motors.py&quot; name=&quot;twist_to_motors&quot; output=&quot;screen&quot;&gt;
    &lt;remap from=&quot;twist&quot; to=&quot;cmd_vel&quot;/&gt;
    &lt;rosparam param=&quot;base_width&quot;&gt;0.353&lt;/rosparam&gt;
    &lt;rosparam param=&quot;rate&quot;&gt;20&lt;/rosparam&gt;
  &lt;/node&gt;
&lt;/launch&gt;
</code></pre>
<p>This launch file assumes your robot:</p>
<ul>
<li>
<p>Takes commands for the wheel power on <code>/lmotor_cmd</code> and <code>/rmotor_cmd</code></p>
</li>
<li>
<p>Publishes the wheel encoder on <code>/lwheel</code> and <code>/rwheel</code></p>
</li>
<li>
<p>The base_width parameter should be set to the wheel spacing of your robot.</p>
</li>
</ul>
<p>If this is not the case, you can change the mapping in the launch file.</p>
<p>As long as you meet these conditions, and the PID values are sane for your robot, you should be able to drive the robot.</p>
<blockquote>
<p>For more information about what is a <a href="software/ros/basics/launch.html">launchfile</a>.
A method for optimizing the PID parameters and calibrating the tick per meter is avalaible <a href="http://wiki.ros.org/differential_drive/tutorials/setup">there</a>.</p>
</blockquote>
<a class="header" href="print.html#sensors" id="sensors"><h2>Sensors</h2></a>
<p>This package allows us to manage the obstacle detection thanks to the data sent by the ultrasonic sensors connected to the arduino and the action to be performed.</p>
<p>The arduino publishes on various topics (<code>ultrasound_x</code>), the data it receives from the sensors.</p>
<p>The package reads the values and depending on the position of the robot (<code>move_base / feedback</code>) and the values sends a stop message on a topic (<code>obstacle / stop</code>).</p>
<blockquote>
<p>For more information about what is a <a href="software/ros/basics/pub.html">publisher</a>, a <a href="software/ros/basics/sub.html">subscriber</a> and <a href="software/ros/arduino/publisher.html">arduino with ros</a>.</p>
</blockquote>
<a class="header" href="print.html#strategy" id="strategy"><h2>Strategy</h2></a>
<p>In this package, we declare the strategy used by each robot in parameter files.</p>
<ul>
<li><strong>initial.yaml</strong>: contains the position of the robots at the beginning of the game based on whether we are the red or green team.</li>
<li><strong>game.yaml</strong>: Contains game-specific information such as the duration of a game.</li>
<li><strong>minus/cortex_actions.yaml</strong>: contains the different actions that the robot must perform.</li>
</ul>
<blockquote>
<p>For more information about what is a <a href="software/ros/basics/params.html">parameter file</a>.</p>
</blockquote>
<a class="header" href="print.html#how-to-run-the-robot" id="how-to-run-the-robot"><h1>How to run the robot</h1></a>
<a class="header" href="print.html#pendant-les-tests" id="pendant-les-tests"><h2>Pendant les tests</h2></a>
<p>To launch Minus, just run the main Minus launchfile that is in the <strong>robot_2018</strong> package.
So just make the following command</p>
<pre><code class="language-bash">roslaunch robot_2018 minus.launch team:=value
</code></pre>
<p>If we want to run rviz to see the simulation of the robot just add a parameter.</p>
<pre><code class="language-bash">roslaunch robot_2018 minus.launch team:=value viz:=true
</code></pre>
<blockquote>
<p>By default, rviz does not start and if we do not set the team parameter, the default value is unknown.</p>
</blockquote>
<a class="header" href="print.html#a2019-1" id="a2019-1"><h1>2019</h1></a>
<a class="header" href="print.html#soja" id="soja"><h1>Soja</h1></a>
<a class="header" href="print.html#code-2" id="code-2"><h1>code</h1></a>
<p>Inside you will find the codes used in the current year's competion.</p>
<a class="header" href="print.html#arduinomotorsino" id="arduinomotorsino"><h1>arduino/motors.ino</h1></a>
<p>This section is used to explain the code used on the Arduino that is used to drive the motors of the big robot and provide feedback of its movements to the raspberry pi.
We think this code could be reused with minimal changes the following years as it solves very basic problems that transcend the competition rules.</p>
<p>You can find this code on the 2019 github repository at the following address: <a href="https://github.com/Ecam-Eurobot/Eurobot-2019/blob/grand_robot/arduino/motors.ino">https://github.com/Ecam-Eurobot/Eurobot-2019/blob/grand_robot/arduino/motors.ino</a></p>
<p>| Don't make the mistakes that we did and try to reuse as much code as you can from previous years! |
| --- |</p>
<p>The hadware environment in whitch this code is supposed to work is described in <a href="robots/2019/soja.md">the following chapter</a></p>
<p>That being said let's take a look at what the code does.</p>
<a class="header" href="print.html#main-purposes" id="main-purposes"><h2>Main purposes</h2></a>
<p>This code has 3 main purposes:
1. Receive driving instructions over ROS and translate them to signals to send to the motors
2. Send encoder data back over ROS so we can localize the robot on the map
3. Activate the mechanical arms that we installed for this year's challenge</p>
<p>We also included some debugging functionalities to test the encoders using LEDs for example. But let's not get ahead of ourselves.</p>
<p>First of all, we have to include all the used libraries. This includes the ROS library to subscribe to ROS topic; the servo library is used to control the mechanical arms; a PID library will manage the PID control loop to drive in a straight line and turn around the center of our robot; and finally, various message types that will be used to transfer information over ROS.</p>
<pre><code class="language-arduino">#include &lt;FastPID.h&gt;
#include &lt;Arduino.h&gt;
#include &lt;Servo.h&gt;
#include &lt;ros.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/Empty.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;geometry_msgs/Vector3.h&gt;
</code></pre>
<p>Once this is done, all our used pins and variables have to be declared and defined. We tried to keep the names as self-explanatory as possible. As such, <code>#define c_LeftEncoderPinA 2</code> means that the first of the two outputs of the left wheel encoder is connected to pin 2 of the Arduino. <code>c_RightMotorPwmPin</code> will be mapped to the pin that will transmit the pulse-width modulated signal that will define the speed of the right motor.</p>
<pre><code class="language-arduino">void setup() {
    Serial.begin(57600);

    // init ROS
    nh.initNode();
    nh.subscribe(sub_lin);
    nh.subscribe(sub_rot);
    nh.subscribe(sub_arm);
    nh.subscribe(sub_stop);
    nh.advertise(pub_encoder);
    nh.advertise(pub_feedback);

    pinMode(c_LeftEncoderPinA, INPUT);
    digitalWrite(c_LeftEncoderPinA, LOW);
    pinMode(c_LeftEncoderPinB, INPUT);
    digitalWrite(c_LeftEncoderPinB, LOW);
    attachInterrupt(digitalPinToInterrupt(c_LeftEncoderPinA), HandleLeftMotorInterrupt, CHANGE);

    pinMode(c_RightEncoderPinA, INPUT);
    digitalWrite(c_RightEncoderPinA, LOW);
    pinMode(c_RightEncoderPinB, INPUT);
    digitalWrite(c_RightEncoderPinB, LOW);
    attachInterrupt(digitalPinToInterrupt(c_RightEncoderPinA), HandleRightMotorInterrupt, CHANGE);
    attachInterrupt(digitalPinToInterrupt(c_RightEncoderPinB), HandleRightMotorInterrupt, CHANGE);

    pinMode(c_LeftLedPin, OUTPUT);
    digitalWrite(c_LeftLedPin, LOW);
    pinMode(c_RightLedPin, OUTPUT);
    digitalWrite(c_RightLedPin, LOW);

    pinMode(c_LeftMotorPwmPin, OUTPUT);
    pinMode(c_LeftMotorDirPin, OUTPUT);
    pinMode(c_RightMotorPwmPin, OUTPUT);
    pinMode(c_RightMotorDirPin, OUTPUT);

    if(diff_PID.err()) {
        nh.logerror(&quot;There is a configuration error!&quot;);
        for (;;) {}
    }

    TCCR2B = TCCR2B &amp; 0b11111000 | 0x01;

    right_arm.attach(c_RightServoPin);
    left_arm.attach(c_RightServoPin);
}
</code></pre>
<p>Several variables will contain specific parameters to fine tune the PID loop and others will be used to store useful information such as the number of ticks one encoder has traveled or the messages that will be send over ROS.</p>
<p>After that, we will instanciate certain objects, provided to us by the libraries we included, so we can make use of them later.</p>
<p>We now have to declare our callback functions that are executed every time nh.spinOnce() is called if a new message is received on a ROS topic. &quot;What?!&quot; I hear you say, &quot;We haven't even started ROS or even told it on which topics to listen!&quot;. And you'd be right. But we have to declare those functions before we tell ROS what topics to subscribe to because in the same line we also have to point to those callback functions that we are declaring. This is done with a pointer which has to point to an already existing function. So that's why we have to declare the function before we initiate ROS. Pfew! So here we are declaring those functions. Those are <code>lin_cb</code>, <code>rot_cb</code>, <code>arm_cb</code>, and <code>stop_cb</code>, who respectively listen to the <code>cmd_lin</code>, <code>cmd_rot</code>, <code>cmd_arm</code>, and <code>cmd_stop</code> topics. Each of these functions do similar things: first, they expect some object in input. These objects are given to us by ROS and will contain the last message received on the topic. Inside the function we then &quot;unpack&quot; the values from those message objects by assigning their attributes to variables declared earlier. Next, we call an external function that will execute an bction based on what message was received on what topic. Those functions will be written later in the file.</p>
<p>We now arrive at the infamous <code>void setup()</code> function provided by the Arduino. As you all certainly know, the Arduino will execute the code inside this function once right after every boot. In this section we will begin the serial communication needed to communicate over ROS (with a baud rate of 57600 to limit the latency of the channel), initiate ROS, actually subscribe to the topics declared earlier, declare all the in and outputs, as well as this peculiar line:</p>
<pre><code class="language-arduino">TCCR2B = TCCR2B &amp; 0b11111000 | 0x01;
</code></pre>
<p>What this does is change the Arduino Mega's pwm frequency on pin 9 and 10 to 31.37255kHz instead of the default 490.20Hz. You can find various explanation on the Arduino forum, but the only official Arduino documentation page that somewhat explains this feature is <a href="ttps://www.arduino.cc/en/Tutorial/SecretsOfArduinoPWM">this one</a>.</p>
<p>After this the only other function that is needed for our program to be compilable is <code>void loop()</code>. The code in this loop is actually nothing else than an infinite <code>while(true)</code> loop that the Arduino will keep running over and over again until the end of times. You can see this loop is much smaller than the previous one.</p>
<pre><code class="language-arduino">void loop() {
    encoder_msg.x = _LeftEncoderTicks;
    encoder_msg.y = _RightEncoderTicks;
    pub_encoder.publish(&amp;encoder_msg);

    nh.spinOnce();
}
</code></pre>
<p>This is pretty straightforward. We set the <code>x</code> and <code>y</code> attributes of the <code>encoder_msg</code> object (whose type is geometry_msgs/Vector3. The <code>z</code> attribute of that oject is not used because we are working on a 2D plane) to the number of ticks the left and right encoder have traveled respectfully. We then have to tell ROS to puplish <code>encoder_msg</code> on the <code>encoder_ticks</code> topic the next time nh.spinOnce() is executed, which happens right after. Optionally, we can also turn our LEDs on or off for debugging purposes here.</p>
<p>We now come to the final section of our code, which is where we declare all the functions that actually tell the motors to turn a certain way or count the number of impulses each encoder is giving in real time.
I won't explain the insides of all those functions here, as they could almost all use a seperate documentation on their own.</p>
<p>The essensial thing here is that those functions are not <em>too</em> badly written and work well as they are. There should be no reason to modify them unless there is a change in harware.</p>
<a class="header" href="print.html#rpiodomcpp" id="rpiodomcpp"><h1>rpi/odom.cpp</h1></a>
<p>This file is part of the odom package on the raspberry pi. Its purpose is to listen to messages published on the <code>encoder_ticks</code> topic and use that information to craft an <code>odom</code> message that we can use to localize our robot on a map using <a href="software/ros/advanced/rviz.md">RViz</a>.</p>
<p>The whole code is <em>heavily</em> inspired by <a href="https://answers.ros.org/question/11973/gathering-wheel-encoder-data-and-publishing-on-the-odom-topic/">this question</a> on the ROS forum.</p>
<a class="header" href="print.html#move-package" id="move-package"><h1>Move package</h1></a>
<p>The move package as it is in the github repository is not quite functional yet. Its purpose was to have a sequence of actions to execute in order ie. dirve forward for 50cm, turn 90° counterclockwise, drive 20 cm forward and activate the arm.</p>
<p>The first thing that we wanted to do is to determine a set of absolute positions to drive to instead of having to tell each action. After losing way too much time trying to understand ROS actions and how to convert a current and target position in the form of an <code>odom</code> message to a set of instructions to be executed by the robot, we came to realise it would be much, <em>much</em> easier to directly have a list of actions to execute. This is exactly what we ended implementing. Unfortunately for us the tournament was only a few days away and we still had many other problems to solve. All this led to some really rushed and unstable code that ended up saving our ass and managed to score just a few points (and even win one match!).</p>
<p>That code has long been burned to the ground and will never be spoken of again. So after that, we were so embarrassed that we tried to rewrite the code a bit better. That code never got quite finished and it is the one that you can find <a href="https://github.com/Ecam-Eurobot/Eurobot-2019/blob/grand_robot/ros_packages/move/src/move.py">here</a>.</p>
<p>The general idea is that we should listen on some topic for a start message, after wich we send the first command to execute. We then wait for a feedback from the arduino telling us when that command has been successfully executed. Once we receive that signal, we can safely send the next instruction.</p>
<a class="header" href="print.html#rpiultrasoundpy" id="rpiultrasoundpy"><h1>rpi/ultrasound.py</h1></a>
<p>In this package, all the data sent by the ultrasonic sensors are read and if the value of one sensor in front on the robot drops below a certain value (10cm in our case), it tells the arduino to pause its current action. Only when all the sensors' readings are acceptable will the robot be able to move. This is necessary for the qualifications of the robot before it can even go on the battlefield.</p>
<p>The way all this is done is pretty simple and works well. Let's analyse this program from the bottom up.</p>
<p>The following lines just tells our program to execute the <code>listener()</code> function  defined above.</p>
<pre><code class="language-python">__name__ == '__main__':
    listener()
</code></pre>
<p>Because we have 7 ultrasonic sensors each publishing on their own topic, we must subscribe to those 7 topics individually. In addition, we have to initialise the rospy node and spin it up. This is done respectively with the first and last line of the <code>listener()</code> function.</p>
<p>We also subscribe to the <code>run</code> topic, which we use to make sure the robot doesn't move after the match time is over.</p>
<pre><code class="language-python">def listener():
    rospy.init_node('ultrasound', anonymous=True)
    rospy.Subscriber('run', String, stop_cb)
    rospy.Subscriber('ultrasound_1', Range, callback, 1)
    rospy.Subscriber('ultrasound_2', Range, callback, 2)
    rospy.Subscriber('ultrasound_3', Range, callback, 3)
    rospy.Subscriber('ultrasound_4', Range, callback, 4)
    rospy.Subscriber('ultrasound_5', Range, callback, 5)
    rospy.Subscriber('ultrasound_6', Range, callback, 6)
    rospy.Subscriber('ultrasound_7', Range, callback, 7)
    rospy.spin()
</code></pre>
<p>When a message appears on one of the sensor's topic, it calls the same <code>callback()</code> function with one extra argument. That argument is there so we know which sensor is seeing the data that is being passed. This way we cam make sure that none of the sensors has an obstacle in front of it before we tell the robot it can move.</p>
<p>The way it works is that we declared a list <code>go_condition</code> that contains all boolean values. Each value corresponds to one sensor and is set to <code>True</code> when the sensor is clear and to <code>False</code> if an obstacle is present. Only when each element of that list is <code>True</code> will it continuously send the &quot;start&quot; string to the <code>cmd_stop</code> topic. If that condition is not met, it will send a &quot;stop&quot; message on the same topic. On the Arduino's side, that topic is being listened to and a boolean variable is set which will prevent going into the next iteration of the PID regulation loop and set the motors speed to 0 instead (while staying in that control loop with all other variables unaffected). The effect of this is that when the obstacle is removed and the &quot;start&quot; string is the one bieng published again, the robot simply continues where it had left as if nothing happened.</p>
<pre><code class="language-python">def callback(data, sensor_num):
    pub = rospy.Publisher('cmd_stop', String, queue_size=10)

    if (data.range &lt; 10 and data.range &gt; data.min_range):
        go_condition[sensor_num] = False
    else:
        go_condition[sensor_num] = True

    if (all(go_condition) == True):
        pub.publish(&quot;start&quot;)
    else:
        pub.publish(&quot;stop&quot;)
</code></pre>
<p>This other callback function is used to set the first entry in the <code>go_condition</code> list to false if the &quot;stop&quot; message has been received when the time is over.</p>
<p>The effect of this is the same as if one of the ultrasonic sensors had an obstacle in front of it idefinitely, keeping the robot still until everything is reset.</p>
<pre><code class="language-python">def stop_cb(msg):
    print(msg.data)
    if (msg.data == &quot;stop&quot;):
    go_condition[0] = False
</code></pre>
<a class="header" href="print.html#encoders" id="encoders"><h1>Encoders</h1></a>
<p>An incremental encoder delivers a certain number of pulses per revolution. The number of pulses is a measure for angular or linear movement. A fixed disc on a shaft is divided into transparent and opaque segments</p>
<p><img src="imagedoc/Encoder1.png" alt="" /></p>
<p>Source : https://instrumentationtools.com/encoder-working-principle/</p>
<p>Most of them have two rows of segments (track A and track B) and a Top Z segment. The two tracks out of phase by 90° indicate the direction of rotation, while the top Z indicates the number of revolutions.</p>
<p><img src="imagedoc/Encoder2.png" alt="" /></p>
<p>Their resolution is the maximum number of pulses it sends per turn, it is expressed in tick/tr (in the encoder that we use we have 4000 ticks/tr).</p>
<a class="header" href="print.html#material" id="material"><h1>Material:</h1></a>
<p>Model: Baumer ITD 01 B14 Incremental Rotary Encoder</p>
<p>The datasheet of this encoder is avaible.</p>
<p>Color Assignment</p>
<p>Green --&gt; Track A</p>
<p>Yellow --&gt; Track B</p>
<p>Brown --&gt; V+</p>
<p>White --&gt; GND</p>
<p>Transparent --&gt; Shield/Housing</p>
<p>We decided to plug the wire on this way for all the encoders:
<img src="imagedoc/Encoder3.png" alt="" />
<img src="imagedoc/Encoder3b.png" alt="" /></p>
<p>To facilitate the wiring, we made a PCB to connect the encoder to the Arduino Mega. Here the pin mapping of the encoders:</p>
<p>Right Encoder: green (track A) --&gt; pin 2
yellow (track B) --&gt; pin 3
Left Encoder: green (track A) --&gt; pin 19
yellow (track B) --&gt; pin 18</p>
<a class="header" href="print.html#shield" id="shield"><h1>Shield</h1></a>
<p>On the shield we have two connectors for the encoders, one connector to plug with the H-bridge and one that can be connected to the battery in case the Arduino is not connected by USB cable to the Raspberry.</p>
<p>We also soldered two LEDs that allow us to verify that the encoders move the code and perform the position calculation.</p>
<p><img src="imagedoc/Shield1.png" alt="" /></p>
<p>You can see how we connect the shield to the H-bridge.</p>
<p><img src="imagedoc/HBridge.png" alt="" /></p>
<p>Warning!! This documentation is only for the new version of the PCB not the old one!</p>
<a class="header" href="print.html#things-that-werent-quite-finished-and-other-research-directions-for-next-years" id="things-that-werent-quite-finished-and-other-research-directions-for-next-years"><h1>Things that weren't quite finished and other research directions for next year(s)</h1></a>
<a class="header" href="print.html#movepy" id="movepy"><h2>move.py</h2></a>
<p>As said earlier, the move package is something that has to be redone from scratch.</p>
<a class="header" href="print.html#use-of-feedback-message" id="use-of-feedback-message"><h3>use of feedback message</h3></a>
<p>The first thing that should be done to have a basic, functioning robot is to try to edit the python file so that it only sends the next command when a message is received on the <code>cmd_feedback</code> topic.</p>
<a class="header" href="print.html#wait-for-start-instruction" id="wait-for-start-instruction"><h3>wait for start instruction</h3></a>
<p>After that it could listen for a message published somewhere by the node managing the starting rope before sending the first command.</p>
<a class="header" href="print.html#ros-actions" id="ros-actions"><h3>ROS actions</h3></a>
<p>Once all that is working and the robot can move around like it should, only then can you begin to research what ROS actions are and try to use that instead of topics to send commands to the motor-driving Arduino. One good thing with ros actions is that they provide feedback and are preemptible as where we had to implement those features in our own (objectively worse) way to achieve a similar functionality with topics.</p>
<p>The way it is implemented now required us to fake an ultrasound sensor to stop the robot after the match time was over. This is obviously a bodge and could be implemented in a much better way.</p>
<a class="header" href="print.html#development-process" id="development-process"><h2>Development process</h2></a>
<a class="header" href="print.html#git--github" id="git--github"><h3>Git &amp; github</h3></a>
<p>Git and especially github are magnificent tools when used correctly. At the start of the project, it would be a good idea to make sure everyone knows how to clone, fork and contribute to a repository. Everyone involved in the project should know what a branch is and what can be done with it.</p>
<a class="header" href="print.html#github-projects" id="github-projects"><h3>Github projects</h3></a>
<p>This year we used Trello and microsoft Teams to plan the whole project out and to share files. Github now proposes similar features directly integrated with the codebase. You can even assign certain cards to issues linked to specific files or commits. It could be worth the time to investigate if and how such a tool could be of any use to manage a project like this (spoiler: it probably is). In any case, using Teams to share code is certainly a very bad idea. That is the exact reason source control was invented in the first place. It could however still be useful to share very large binary files like VM images or to store backups of the raspberry pi's sd card.</p>
<a class="header" href="print.html#graphic-chart" id="graphic-chart"><h1>Graphic chart</h1></a>
<p><img src="graphic/graphic_chart.PNG" alt="alt text" /></p>
<a class="header" href="print.html#colors" id="colors"><h2>Colors</h2></a>
<p>The used colors in HEX format :</p>
<ul>
<li><strong>Blue</strong> :  012D5A</li>
<li><strong>Yellow</strong> : FFC72C</li>
</ul>
<a class="header" href="print.html#fonts" id="fonts"><h2>Fonts</h2></a>
<p>The fonts are available on https://dafont.com</p>
<ul>
<li><strong>ECAM</strong> : SF Distant Galaxy Italic</li>
<li><strong>Robotics</strong> : SF Distant Galaxy Outline Italic</li>
<li><strong>Brussels</strong> : Open Sans</li>
<li><strong>ENGINEERING SCHOOL</strong> : Open Sans Bold</li>
</ul>
<a class="header" href="print.html#the-polo" id="the-polo"><h2>The polo</h2></a>
<p>The polo were manufactured by <em>4eme dimensions</em> : http://www.4dimension.be/.</p>
<p>The vector file is available here : XXX</p>
<a class="header" href="print.html#the-poster" id="the-poster"><h2>The poster</h2></a>
<p><img src="graphic/poster_rendu.png" alt="alt text" /></p>
<p>The poster was printed by <em>Graphoprint-services-europe</em>  in A0.</p>
<p>The vector file is available here :</p>
<a class="header" href="print.html#files" id="files"><h2>Files</h2></a>
<p>The Adobde Illustrator files of the polo and the poster are available on the github.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
